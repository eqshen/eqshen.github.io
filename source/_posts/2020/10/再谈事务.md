---
title: 再谈事务
date: 2020-10-02 23:30:14
tags:
    - 事务
    - Transaction
categories:
  - ['数据库','事务']

---

## 再谈事务

最近在复习事务相关的知识，结合实际工作中的方案，加深对事务的理解

### 一、基础概念回顾

#### ACID

- Atomicity（原子性）：多个写操作，要全部成功，要么全部失败/回滚 

- Consistency（一致性）：

  - 事务可以保障数据库从一个状态转移到另一个状态，没有中间状态。（如A向B转账）

  - 中间状态不可以被观察到。

    > 针对“中间状态”说下个人理解，在强一致性的事务中，肯定是要求无法被观察到的；但是在弱一致性的柔性事务中，中间状态是可以被观察到的，只要满足最终一致性即可。

- Isolation（隔离性）：两个并发的事务在执行时，互不影响。事务1对某个数值的修改不能影响到事务2，事务2也不知道事务1干了啥，完全是两个黑盒操作。当如果两个事务同时对某一资源进行访问时，就要进行加锁控制，并行变串行，但依然满足“并发”的概念。

- Durablity（持久性）：事务成功提交后，更改永久保存，不能回滚。

#### 隔离级别

| 事务隔离级别                          | 发生脏读 | 不可重复读 | 发生幻读 |
| ------------------------------------- | -------- | ---------- | -------- |
| Read Uncommitted 读未提交             | 是       | 是         | 是       |
| Read Committed 读已提交（不可重复读） | 否       | 是         | 是       |
| Repeatable Read 可重复读              | 否       | 否         | 是       |
| Serializable 串行化                   | 否       | 否         | 否       |

- 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
- 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。关注点是已存在数据的修改。
- 幻读：跟RC容易混，举例：事务A读取某班级所有学生数据共32人，然后事务B插入了2名新学生数据到该班级，事务A再次读取所有学生数据，发现有34人。事务A:"怎么变成34了难道刚才我发生幻觉了？"....这就是幻读，关注点在行数的增加。
> 如果是减少2人，还是幻读吗？答案：不是了。`幻读`强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。所以`减少两人`这种情况应该算是 **不可重复读**。

### 二、分布式事务

##### 1.何为分布式事务

相对于本地事务而言，在SOA等架构下，用户一次操作，需要修改**多个数据库**的数据且要求该次操作要满足事务特性（ACID）, 而跨越了多个数据库实例的情况下，单机事务就不适用了。

**举个栗子**：用户的资产余额数据保存在 订单库A，而用户的积分保存在 活动库B，库存数据保存在 商品库C。按照业务要求，用户完成一笔下单，要赠送订单金额*100的活动积分。那么用户单次的下单行为就至少存在以下数据库修改：

- 订单库A 金额减少 x元
- 订单库B 用户积分增加 x*100点
- 商品库C 要进行扣库存操作

以上 就是典型需要使用分布式事务的场景了。

##### 2. 分布式理论

比较常见的主要是**CAP理论**和**BASE理论**，这里不做介绍可以自行百度复习。

### 三、常见的分布式方案(XA与TCC)

#### 1.DTP模型-二阶段提交（2PC）

> Distributed Transaction Processing（DTP）采用的是XA协议

模型中涉及到的角色

- TM,Transaction Manager 事务管理器（也称协调者）
- RM, Resource Manager 资源管理器（也称参与者）
- AP,Application 应用，通常和RM看做一个整体

##### 第一阶段 投票阶段

目的：TM询问各个数据库实例参与者RM 是否具备正常执行事务的条件。

主要步骤

 1. 协调者向所有的参与者发送事务执行请求，并等待参与者反馈事务执行结果
 2. 事务参与者收到请求之后，执行事务，**但不提交**，并记录事务日志。
 3. 参与者将自己事务执行情况反馈给协调者，同时**阻塞等待**协调者的后续指令。

##### 第二阶段 事务提交阶段

第一阶段的询问将会出现三种情况

1. 所有参与者都返回成功
2. 部分参与者成功，部分返回失败
3. 协调者等待超时

###### 对于第1种情况，协调者会通知所有参与者提交事务

<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjbb6cuxwwj30m20gnwfg.jpg" style="zoom:50%;" />

###### 对于第2，3种情况，协调者就会发送回滚通知

<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjbb8fo47gj30m20gnjsc.jpg" style="zoom:50%;" />

##### 两阶段方案的不足之处

1. 协调者的单点问题，协调者挂了，参与者会无限等待（可引入超时机制解决）；
2. 同步阻塞，所有参与者都同步阻塞等待协调者“指挥”下一步操作，效率太低；
3. 数据不一致，两阶段协议的整个流程中，还是存在导致数据不一致的可能（部分参与者提交失败，协调者与参与者同时挂了）

#### 2.DTP模型-三阶段提交（3PC）

是三阶段协议王者归来吗？且往下看

三阶段主要比二阶段增加了一个“预询”阶段，以及超时策略来减少集群的阻塞时间。

##### 第一阶段 Can_Commit

1. 协调者向所有参与者发送事务询问通知，询问是否可以执行事务，并等待响应
2. 各个参与者依据自身状态给出 预估值答复，如果可以执行事务，就进入预备状态

##### 第二阶段 Pre_Commit

第一阶段的“预询”结果也会有三种

1. 所有参与者都返回确定信息
2. 部分参与者回复 否定信息
3. 协调者等待超时

对于第1种情况，协调者会向所有参与者发送执行事务请求（和两阶段协议的第一阶段内容一样）：

1. 协调者向所有的事务参与者发送事务执行通知
2. 参与者收到通知后，执行事务，**但不提交**
3. 参与者将事务执行情况返回给客户端

对于第2、3种情况，协调者会发送abort通知，所有参与者退出“预备”状态

<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjbbadcbe0j30mc0gn754.jpg" style="zoom:50%;" />

##### 第三阶段 Do_Commit

第二阶段的执行结果也会有 三种情况：

1. 所有参与参与者执行事务成功
2. 部分参与者执行事务失败
3. 协调者等待超时

同样的，协调者会针对上述3种情况进行不同的处理

###### 对于第1种，协调者会向所有参与者发送事务提交请求

<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjbbbah8o8j30k20qagmz.jpg" style="zoom:50%;" />

###### 对于第2，3种，协调者会发送事务回滚通知给所有参与者。

<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjbbca965kj30ks0qaq4b.jpg" style="zoom:50%;" />

> 补充，如果在该阶段，参与者等待协调者发送的消息超时，那么默认会提交事务。而如果此时协调者发送的是回滚通知，那么还是会出现数据不一致的可能，也就是说，三阶段相比两阶段主要提交了两点：1.第一阶段的预询操作更加轻量级，如果有部分参与者无法执行事务，直接Abort，而不用所有参与者预执行事务；2.增加了超时自动提交机制，避免了长时间等待造成资源浪费。

> 思考：如果第三阶段，最后有参与者返回“提交事务失败”，该怎么处理？

#### 2PC和3PC的区别
- 2PC 只有协调者超时机制，3PC协调者参与者都有超时机制
- 3PC 将2PC的第一阶段拆为2步，粒度更细，资源锁定时间更短

#### 3.TCC方案

TCC是try,confirm/cancel的简称，即TCC主要有两阶段组成，分别是Try阶段和Confirm/Cancel阶段。

> 通俗点讲，一个完整的事务 = Try + Confirm或Cancel

TCC方案是一种柔性事务方案的实现，那么何为`柔性事务`？

##### 一阶段-Try

Try中的逻辑与传统事务机制中的业务逻辑相同。该阶段主要的工作是：完成所有业务检查，预留必须的业务资源。

##### 二阶段-Confirm

真正执行的业务逻辑，不做任何业务检查，**但只能使用Try阶段预留的资源**。此外，confirm操作还有几点要求

1. Try操作成功，Confirm操作一定会成功，不存在失败的情况；
2. Confirm操作要满足幂等性，保证一笔分布式事务能且只能成功一次。

##### 二阶段-Cancel

释放 Try 阶段预留的业务资源。同样的，Cancel 操作也需要满足幂等性。

##### TCC方案存在的三个问题

1. 空回滚 - 没有调用 try，直接调用Cancel，要求在设计系统时，能够是被空回滚请求，并处理。
2. 幂等 - 由于网络原因Contirm、Cancel接口被多次调用，要保证重复执行与只执行一次具有同样效果，可以设置当时事务状态来避免
3. 悬挂 - Cancel比Try先执行了。什么情况下会发生：网络原因Try操作阻塞，超时后，TCC框架协调器调用Cancel接口，Cancel执行后，Try操作才到达。解决方案：执行try操作之前先查询一下二阶段接口是否被执行

##### 其他

1. TCC相对于 XA 等传统模型，其特征在于它不依赖 RM 对分布式事务的支持，而是通过对业务逻辑的分解来实现分布式事务。
2. TCC要根据自身业务模型特点来控制并发。

### XA与TCC的异同

##### 隔离性

- XA对隔离性的控制，是通过对依赖的资源进行加锁的方式，且要求对锁的持有要到最后一阶段，这种长时间对资源进行加锁的方式，会使得并发性能非常低下

- TCC对隔离性的处理思想是通过业务层来控制，Try阶段结束后就释放底层数据库锁，由业务层对持有的资源进行加锁，从而降低锁的粒度，提高并发性。

  > 上面这是什么意思呢？举个例子，A账户有100元，A向B账户转账30元，在try阶段会对A账户扣除30元，并增加30元冻结资金（这依赖底层数据库锁保证原子性），这样就在业务层面把30块给锁定了（转为业务层加锁），然后Confirm阶段向B账户增加30元，如果增加成功，则将A账户冻结资金扣除；如果失败则执行Cancel，将30元冻结资金返回给A账户。这样即使A账户需要同时给多个账户转账30元，也不是出现”双花“的情况。

##### 原子性

- XA通过两阶段提交协议来控制原子性，即Prepare, Commit/Rollback
- TCC也是通过两阶段来控制原子性，只不过更像是应用层的原子性，Try相当于 Prepare，Confirm相当于Commit，Cancel相当于Rollback。

##### 一致性

- XA于TCC的一致性都是由其原子性和隔离性来保证
- XA方案的一致性是强一致性，数据的中间过程状态是无法被观察到的；而TCC的中间状态是可以被观察到的，是一种弱一致性（追求最终一致性）。

### 四、常见的开源解决方案

1. [Seata]( http://seata.io/zh-cn/docs/overview/what-is-seata.html)

2. [Tcc-Transaction](https://github.com/changmingxie/tcc-transaction)

3. [ByteTCC](https://github.com/liuyangming/ByteTCC)

### 五、最后

以上内容只是整理作为学习笔记，仅抛砖引玉作用，大家共同学习进步，你学废了嘛？

### 六、参考

1. [分布式事务综述](https://mp.weixin.qq.com/s?__biz=MzUzMzU5Mjc1Nw==&amp;mid=2247483681&amp;idx=1&amp;sn=05845495c5ef33683addd98fffc72106&amp;chksm=faa0eefbcdd767edbf46cea6f223b426e276dd4d9b19cce64f59387590818f5e4eb96c7d2533&amp;mpshare=1&amp;scene=2&amp;srcid=0118GSYShGZaOyCndUoAqsae&amp;from=timeline#rd )
2. [分布式事务-两阶段与三阶段提](https://blog.csdn.net/pyycsd/article/details/102803015)
3. [TCC事务机制简介](https://www.bytesoft.org/tcc-intro/)
4. [如何理解TCC分布式事务](https://www.zhihu.com/question/48627764)
5. [分布式事务 Seata TCC 模式深度解析](https://juejin.im/post/6844903829603876878)




