---
title: 插件集成-类加载简单实践及踩坑
date: 2022-01-09 14:22:27
tags:
    - JVM
    - 类加载
categories:
  - ['实践','类加载']
---


### 插件集成-类加载简单实践及踩坑

#### **背景**

在项目中，有这样一个需求场景，系统web端要支持插件功能，插件功能其中一点就是要支持 jar包上传（jar包中包含插件逻辑），然后把插件应用在某个流程中。如：要把IP地址 192.168.12.13 转为 192.168.12。

支持插件的一个好处就是，一些前置转换就比较灵活，不需要每次都改代码重新部署。

#### **V1 Begin to explore**

项目中定义一个模板接口 IPluginJarTemplate，所有jar插件需要实现该模板接口 IPluginJarTemplate。然后利用JAVA SPI加载 IPluginJarTemplate的所有实现类的实例并缓存备用。

```java
@Slf4j
public class PluginJarClassLoader extends ClassLoader{

    private final JarFile jarFile;

    public PluginJarClassLoader(ClassLoader parent,JarFile jar){
        super(parent);
        this.jarFile = jar;
    }

    @Override
    protected Class<?> findClass(String className) throws ClassNotFoundException {
        String filename = className.replace('.', File.separatorChar) + ".class";
        JarEntry jarEntry = jarFile.getJarEntry(filename);

        if(jarEntry == null){
            throw new ClassNotFoundException(filename);
        }

        byte[] classBytes = null;
        try(InputStream inputStream = jarFile.getInputStream(jarEntry)){
            ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
            int nextValue;
            while (-1 != (nextValue = inputStream.read())) {
                byteStream.write(nextValue);
            }
            classBytes = byteStream.toByteArray();
        } catch (IOException e) {
            log.error("插件加载类出错： class : {},error: {}",filename,e);
            throw new RuntimeException(filename);
        }
        return defineClass(className, classBytes, 0, classBytes.length);
    }
}
```



类加载

```java
            PluginJarClassLoader pluginJarClassLoader = new PluginJarClassLoader(ClassLoader.getSystemClassLoader(), new JarFile(file));

            //使用JAVA SPI加载IPluginJarTemplate所有实现类实例
            ServiceLoader<IPluginJarTemplate> allImplementations = ServiceLoader.load(IPluginJarTemplate.class, pluginJarClassLoader);
            Iterator<IPluginJarTemplate> iterator = allImplementations.iterator();
            if (iterator.hasNext()){
                IPluginJarTemplate funcImplementation = iterator.next();
                String cacheKey = PluginJarFileCache.genCacheKey(pluginDto);
                PluginJarFileCache.put(cacheKey,funcImplementation);
                log.info("加载Jar类：{}",funcImplementation.getClass().getName());
            }
```



但上述加载流程存在问题，无法加载到类

Debug跟进SPI源码，发现关键点在于 loader.getResources(fullName) ，见下方代码，fullName这个变量的值形如：META-INF/services/xxxxx , 也就是说，会通过自定义类加载器去加载 SPI所需的配置文件

```java
private LazyIterator(Class<S> service, ClassLoader loader) {
            this.service = service;
            this.loader = loader;
        }

        private boolean hasNextService() {
            if (nextName != null) {
                return true;
            }
            if (configs == null) {
                try {
                    String fullName = PREFIX + service.getName();
                    if (loader == null)
                        configs = ClassLoader.getSystemResources(fullName);
                    else
                        configs = loader.getResources(fullName);
                } catch (IOException x) {
                    fail(service, "Error locating configuration files", x);
                }
            }
            while ((pending == null) || !pending.hasNext()) {
                if (!configs.hasMoreElements()) {
                    return false;
                }
                pending = parse(service, configs.nextElement());
            }
            nextName = pending.next();
            return true;
        }
```



而我们自定义类加载的继承关系是 PluginJarClassLoader extends ClassLoader , 而getResources方法 ClassLoader 的默认实现是

```java
    public Enumeration<URL> getResources(String name) throws IOException {
        @SuppressWarnings("unchecked")
        Enumeration<URL>[] tmp = (Enumeration<URL>[]) new Enumeration<?>[2];
        if (parent != null) {
            tmp[0] = parent.getResources(name);
        } else {
            tmp[0] = getBootstrapResources(name);
        }
        tmp[1] = findResources(name);

        return new CompoundEnumeration<>(tmp);
    }
```



通过上述代码，不难发现关键点来到了 tmp[1] = findResources(name) 这个地方，而 findResources的默认实现是

```java
protected Enumeration<URL> findResources(String name) throws IOException {
        return java.util.Collections.emptyEnumeration();
    }
```



所以无法加载插件中的类，就自然不难理解了。

#### **V2 How to reslove**

到这，就有两种方法了

- 第一，自定义类加载器中重写 findResources
- 第二，找一个 已经重写了findResources方法的类加载器，通过类继承关系，发现URLClassLoader符合条件

两种方法我们都试一下

##### **重写findResources**

```java
@Override
    protected Enumeration<URL> findResources(String name) throws IOException {

        JarEntry jarEntry = jarFile.getJarEntry(name);
        if(jarEntry != null) {
            System.out.println("找到资源" + jarEntry.getName());
            File file = new File("/tmp/jarEntry_temp");
            FileUtil.writeFromStream(jarFile.getInputStream(jarEntry), file);

            return Collections.enumeration(Collections.singletonList(file.toURI().toURL()));

        }
        return java.util.Collections.emptyEnumeration();
    }
```



然后测试

```java
public void test() throws IOException {
        JarFile jarFile = new JarFile("/Users/eqshen/workspace/plugin-review/plugin-client/build/libs/plugin-client-1.0-SNAPSHOT.jar");
        PluginJarClassLoader classLoader = new PluginJarClassLoader(this.getClass().getClassLoader(), jarFile);

        ServiceLoader<IPluginJarTemplate> allImplementations = ServiceLoader.load(IPluginJarTemplate.class, classLoader);
        Iterator<IPluginJarTemplate> iterator = allImplementations.iterator();
        while (iterator.hasNext()){
            IPluginJarTemplate funcImplementation = iterator.next();
            log.info("加载Jar类：{}",funcImplementation.getClass().getName());
            log.info("======= result: {}",funcImplementation.execute("hello","world"));
        }
    }
```



测试发现类成功加载并执行

##### **使用URLClassLoader**

```java
public void test() throws MalformedURLException {
        File file = new File("/Users/eqshen/workspace/plugin-review/plugin-client/build/libs/plugin-client-1.0-SNAPSHOT.jar");

        ClassLoader ucl = new URLClassLoader(new URL[] {file.toURI().toURL()}, this.getClass().getClassLoader());
        ServiceLoader<IPluginJarTemplate> allImplementations = ServiceLoader.load(IPluginJarTemplate.class, ucl);
        Iterator<IPluginJarTemplate> iterator = allImplementations.iterator();

        while (iterator.hasNext()){
            IPluginJarTemplate funcImplementation = iterator.next();
            log.info("=======result: {}",funcImplementation.execute("hello","world"));
            log.info("加载Jar类：{}",funcImplementation.getClass().getName());
        }
    }
```



通过这种方式，也可以成功加载 IPluginJarTemplate的所有实现类。

显然，通过第二种方式更简洁、符合实际应用

#### **踩坑**

其实上面 通过 URLClassLoader加载的方式还是有个坑的， URLClassLoader构造函数传入的父类是 ClassLoader.getSystemClassLoader(), 这个代码在本地IDEA中启动是没问题的，但是如果发到测试环境或者本地通过 java -jar的方式启动，就会报错 ServiceConfigurationError not subtype, 通过google查找资源，大概了解到原因如下：

- plugin-management-spi-1.0-SNAPSHOT.jar 这个jar包中包含了 IPluginJarTemplate.class这个类，由URLClassloader加载器加载
- 而我们插件使用的项目中也存在 IPluginJarTemplate.class这个类，由 未知类加载器（暂时称为X）加载， X肯定不等于 ClassLoader.getSystemClassLoader()
- 在使用 ServiceLoader.load(IPluginJarTemplate.class, ucl) 获得类的实例的时候，会把 URLClassloader 加载的 IPluginJarTemplate.class子类 实例执行 X类加载器加载的 IPluginJarTemplate.class （多态的表现）
- 虽然 二者逻辑上是 父子关系，但分别由两个类加载器加载，则报错

##### **证实一下猜想**

​      

​     

​	  

```java
ClassLoader parent = this.getClass().getClassLoader();
log.info("parent classloader: {},system:{}",parent,ClassLoader.getSystemClassLoader());
ClassLoader ucl = new URLClassLoader(new URL[] {file.toURI().toURL()}, parent);
```



只需要证明 this.getClass().getClassLoader() 和 ClassLoader.getSystemClassLoader() 不是同一个就能说得通了

本地IDEA跑起来，上面二者确实相同，都是AppClassLoader，但以java -jar的方式运行，输出日志如下

```java
parent classloader:org.springframework.boot.loader.LaunchedURLClassLoader@7c51f34b，system:sun.misc.Launcher$AppClassLoader@18b4aac2
```

