---
title: 从审计日志(操作日志)说起
date: 2021-09-21 12:42:08
tags:
    - AOP
---


### 从审计日志(操作日志)说起

时隔一年，偷懒了一年，再次开始写日志，补补技术债

#### 背景
在公司日常的开发中，经常会遇到记录操作（审计）日志的情况，格式像这样：`法外狂人张三 修改了 xxx配置，从 123 修改为 456，影响 1 行`。如果一个项目中crud的接口比较少，那我们完全可以在 接口中硬编码，这中方式也是最直接最快的方式，但是对于一个追求完美的“技术癖”来说，还是存在以下担忧的地方

- 接口可能不是同一个人开发，日志的格式如何统一？模板方法？
- 后续修改，每个地方都要修改，工作量就比较大，不好维护
- 通用逻辑植入业务代码，很不爽
- 每个接口入参和出参格式不一样，如何从中提取参数信息？

#### 具体需求举例

各个业务需要统一将操作日志记录并统一上报，上报的报文要包含以下内容：

- 操作人  : 操作人的userId
- 操作时间：2021年09月21日14:31:34
- 操作类型：C - 增加，R - 读，U - 更新，D - 删除
- 操作对象：如 orderNo , userId
- 影响行数：22

其中影响行数，在读取的情况下指读取的行数，写的情况下指影响的行数，这些都是要根据具体的业务逻辑来确定的，无法抽象共用

| 以上就是一个具体的需求内容简化，接下来就是方案设计了。



#### 常见的解决方案
1. 从数据层面入手，订阅数据库Binlog
    简单来说，就是通过Canal订阅MySQL的binlog, 这样每次就能知道哪张表、哪行被修改了。
    - 好处：直接和业务逻辑解耦
    - 缺点：复杂的业务逻辑无法表现出来，如果一个接口中修改了很多接口，甚至还有RPC调用，这种情况下就不太实用这种方案了。

2. 定义类似LogUtil一样的工具类，抽象入参，在工具类中实现模板化，在需要记录日志的地方调用工具类
    
    这种方式也是比较容易想到，而且是比较简单的实现。

3. 自定义注解 + Aop + SpEL实现解耦
    
    这种方法就是我们要实现的方式了，要做一个有追求的`新时代农民工`。
    
#### 具体实现

1. 首先定义注解
用于在controller方法上进行标记，并提供切面标记

```
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
public @interface AuditLog {

    /**
     * 操作类型
     * @return
     */
    OperateType operateType();

    /**
     * 操作对象表达式
     * @return
     */
    String opTargetEL();

    /**
     * 影响行数表达式
     * @return
     */
    String effectRowsEL();

}
```

2. 定义使用到的实体类

用于存储 AuditLog 在aop过程中所需要的中间过程数据
```
/**
 * 存储切面过程中一些元数据
 */
@Data
public class AuditLogAopMetaDTO {
    private HttpServletRequest httpServletRequest;

    private AuditLog auditLog;

    private String httpMethodType;

    /**
     * Get请求参数
     */
    private Map<String,Object> reqParam;

    /**
     * Post请求参数
     */
    private Object postParam;
}
```

用于存储最终的操作日志结果
```
/**
 * 操作日志对象
 */
@Data
public class AuditLogDTO {

    private LocalDateTime opTime;

    /**
     * @see com.eqshen.auditlogstarter.enums.OperateType
     */
    private String operateType;

    /**
     * 操作人账号或id
     */
    private String opAccount;

    /**
     * 操作对象，如 订单号，用户id等
     */
    private String opTarget;

    /**
     * 操作结果，影响行数等
     */
    private String opResult;
}

```

3. 定义切面处理类

这里是主要的逻辑, 代码不复杂。

```
@Aspect
@Component
@Slf4j
public class AuditLogInterceptor {

    @Pointcut("@annotation(com.eqshen.auditlogstarter.annotation.AuditLog)")
    public void pointcut(){
    }

    @Around("pointcut()")
    public Object around(ProceedingJoinPoint point) throws Throwable {

        Object result = null;
        final AuditLogDTO auditLogDTO;
        final AuditLogAopMetaDTO auditLogAopMetaDTO = this.beforeProcess(point);

        try{
            result = point.proceed();
        }finally {
            auditLogDTO = this.afterProcess(auditLogAopMetaDTO, result);

            //异步推送kafka
            this.asyncSendToKafka(auditLogDTO);
        }

        return result;
    }

    private AuditLogAopMetaDTO beforeProcess(ProceedingJoinPoint point){
        AuditLogAopMetaDTO auditLogAopMetaDTO = new AuditLogAopMetaDTO();
        try{
            RequestAttributes ra = RequestContextHolder.getRequestAttributes();
            ServletRequestAttributes sra = (ServletRequestAttributes) ra;
            if (sra == null) return null;

            final HttpServletRequest request = sra.getRequest();

            String methodType = request.getMethod();;
            Method method = AopUtil.getMethod(point);
            AuditLog auditLog = method.getAnnotation(AuditLog.class);

            auditLogAopMetaDTO.setAuditLog(auditLog);
            auditLogAopMetaDTO.setHttpMethodType(methodType);
            auditLogAopMetaDTO.setHttpServletRequest(request);
            auditLogAopMetaDTO.setReqParam(AopUtil.getParamsNameAndValue(point));
            auditLogAopMetaDTO.setPostParam(AopUtil.getPostParam(point));


        }catch (Exception e){
            log.error("预处理失败",e);
        }
        return auditLogAopMetaDTO;
    }

    private AuditLogDTO afterProcess(AuditLogAopMetaDTO aopMeta, Object result){
        if(aopMeta == null){
            return null;
        }
        final AuditLog auditLog = aopMeta.getAuditLog();

        Object opTarget = SpELUtil.explainEl(aopMeta.getPostParam(),auditLog.opTargetEL());

        if(opTarget == null){
            opTarget = SpELUtil.explainEl(aopMeta.getReqParam(),auditLog.opTargetEL());
        }

        String effectRows = String.valueOf(SpELUtil.explainEl(result,auditLog.effectRowsEL()));

        AuditLogDTO auditLogDTO = new AuditLogDTO();
        auditLogDTO.setOpTime(LocalDateTime.now());
        auditLogDTO.setOperateType(auditLogDTO.getOperateType());
        auditLogDTO.setOpAccount(null);//一般从Context中获取当前登录的用户信息
        auditLogDTO.setOpResult(effectRows);
        auditLogDTO.setOpTarget(String.valueOf(opTarget==null?"":opTarget));

        return auditLogDTO;

    }

    private void asyncSendToKafka(AuditLogDTO auditLogDTO){
        if(auditLogDTO == null) return;
        //推荐使用线程数池操作,此处仅输出日志
        log.info("======> 操作日志：{}", JSONObject.toJSONString(auditLogDTO));
    }
}
```

其中的一个 SpELUtil工具类是用来解析spel表达式的，也很简单

```
@Slf4j
public class SpELUtil {
    //thread-safe
    private static final SpelExpressionParser parser = new SpelExpressionParser();

    private static final TemplateParserContext parserContext = new TemplateParserContext("#{", "}");



    public static Object explainEl(Object obj, String spELExpression){
        if (StringUtils.isEmpty(spELExpression) || obj == null) {
            return null;
        }

        try {
            // spring的表达式上下文对象
            StandardEvaluationContext context = new StandardEvaluationContext();
            context.addPropertyAccessor(new MapAccessor());//增加对map的访问支持
            context.setRootObject(obj);


            Expression expression = parser.parseExpression(spELExpression, parserContext);
            return expression.getValue(context);
        } catch (Exception e) {
            log.error("SpEL解析失败, 表达式: {}, 输入: {}", spELExpression, JSONObject.toJSONString(obj), e);
        }
        return null;
    }

}
```

4. 测试
定义TestController，简单演示如何使用

```
@RestController
public class TestController {

    @GetMapping("/listUsers")
    @AuditLog(opTargetEL = "",operateType = OperateType.READ,effectRowsEL = "#{data.size()}")
    public JSONObject queryUserList(){
        JSONObject resp = new JSONObject();
        resp.put("code",200);
        resp.put("msg","success");

        List<UserInfo> userList = new ArrayList<>();
        userList.add(new UserInfo("u-007","张三",2,"17621345678"));
        userList.add(new UserInfo("u-001","李四",3,"17621345679"));

        resp.put("data",userList);
        return resp;
    }

    @GetMapping("/getUserInfo")
    @AuditLog(operateType = OperateType.READ,
            opTargetEL = "查询用户信息：#{userId}",
            effectRowsEL = "#{data == null?0:1}")
    public JSONObject getUser(String userId){
        JSONObject resp = new JSONObject();
        resp.put("code",200);
        resp.put("msg","success");
        resp.put("data",new UserInfo("u-007","张三",2,"17621345678"));

        return resp;
    }


    @PostMapping("/operateUser")
    @AuditLog(operateType = OperateType.UPDATE,
            opTargetEL = "用户id: #{userId}", //必须跟 userInfo对象中的属性名称一致
            effectRowsEL = "#{code == 200?1:0}")
    public JSONObject operateUser(@RequestBody UserInfo userInfo){

        //用于测试异常情况
        if(Objects.equals(userInfo.getUserId(), "1234")){
            throw new RuntimeException("用户不存在");
        }

        JSONObject resp = new JSONObject();
        resp.put("code",200);
        resp.put("msg","success");
        return resp;
    }
}
```

- 测试1
请求及返回：
```
GET http://localhost:8080/listUsers

HTTP/1.1 200 
Content-Type: application/json
Transfer-Encoding: chunked
Date: Sat, 25 Sep 2021 09:10:57 GMT
Keep-Alive: timeout=60
Connection: keep-alive

{
  "msg": "success",
  "code": 200,
  "data": [
    {
      "userId": "u-007",
      "name": "张三",
      "level": 2,
      "mobile": "17621345678"
    },
    {
      "userId": "u-001",
      "name": "李四",
      "level": 3,
      "mobile": "17621345679"
    }
  ]
}
```

日志输出：
`======> 操作日志：{"opResult":"2","opTarget":"","opTime":"2021-09-25T17:07:38.093127000"}
`

- 测试2
请求及返回： 
```
GET http://localhost:8080/getUserInfo?userId=1234

HTTP/1.1 200 
Content-Type: application/json
Transfer-Encoding: chunked
Date: Sat, 25 Sep 2021 09:09:11 GMT
Keep-Alive: timeout=60
Connection: keep-alive

{
  "msg": "success",
  "code": 200,
  "data": {
    "userId": "u-007",
    "name": "张三",
    "level": 2,
    "mobile": "17621345678"
  }
}
```

日志输出：
`======> 操作日志：{"opResult":"1","opTarget":"查询用户信息：1234","opTime":"2021-09-25T17:11:40.489187000"}
`

- 测试3
请求及返回：
```
POST http://localhost:8080/operateUser

HTTP/1.1 200 
Content-Type: application/json
Transfer-Encoding: chunked
Date: Sat, 25 Sep 2021 09:12:49 GMT
Keep-Alive: timeout=60
Connection: keep-alive

{
  "msg": "success",
  "code": 200
}
```

日志输出：
`======> 操作日志：{"opResult":"1","opTarget":"用户id: 12345","opTime":"2021-09-25T17:13:47.193806000"}
`

#### 补充

1. 关于SpEL的语法可以去看Spring官方文档
 - http://itmyhome.com/spring/expressions.html
 - https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html


2. 完整仓库地址

 - https://github.com/eqshen/audit-log-starter