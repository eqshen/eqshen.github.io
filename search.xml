<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于我</title>
    <url>/2020/03/22/sys-aboutMe/</url>
    <content><![CDATA[<p><code>The more you know,the more you don&#39;t know.</code></p>
<h1 id="Hello-this-is-EQShen"><a href="#Hello-this-is-EQShen" class="headerlink" title="Hello, this is EQShen"></a>Hello, this is EQShen</h1><br/>

<h3 id="一个在互联网苟且偷生的程序员，That’s-all"><a href="#一个在互联网苟且偷生的程序员，That’s-all" class="headerlink" title="一个在互联网苟且偷生的程序员，That’s all -_-"></a>一个在互联网苟且偷生的程序员，That’s all -_-</h3><hr>
<h4 id="意志产生希望，希望孕育梦想，梦想改变世界"><a href="#意志产生希望，希望孕育梦想，梦想改变世界" class="headerlink" title="意志产生希望，希望孕育梦想，梦想改变世界"></a>意志产生希望，希望孕育梦想，梦想改变世界</h4><br/>

<h3 id="联系我-x65-x71-115-104-x65-110-64-111-x75-116-108-111-x6f-107-46-99-111-x6d"><a href="#联系我-x65-x71-115-104-x65-110-64-111-x75-116-108-111-x6f-107-46-99-111-x6d" class="headerlink" title="联系我: &#x65;&#x71;&#115;&#104;&#x65;&#110;&#64;&#111;&#x75;&#116;&#108;&#111;&#x6f;&#107;&#46;&#99;&#111;&#x6d;"></a>联系我: <a href="mailto:&#x65;&#x71;&#115;&#104;&#x65;&#110;&#64;&#111;&#x75;&#116;&#108;&#111;&#x6f;&#107;&#46;&#99;&#111;&#x6d;">&#x65;&#x71;&#115;&#104;&#x65;&#110;&#64;&#111;&#x75;&#116;&#108;&#111;&#x6f;&#107;&#46;&#99;&#111;&#x6d;</a></h3><br/>
<br/>
<br/>
<br/>
<br/>
<br/>]]></content>
      <categories>
        <category>系统</category>
        <category>系统-关于</category>
        <category>二级分类demo</category>
        <category>关于</category>
        <category>about</category>
      </categories>
      <tags>
        <tag>关于</tag>
      </tags>
  </entry>
  <entry>
    <title>本博客构建指南</title>
    <url>/2020/03/22/construction-guide/</url>
    <content><![CDATA[<h1 id="hexo博客搭建"><a href="#hexo博客搭建" class="headerlink" title="hexo博客搭建"></a>hexo博客搭建</h1><h3 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1 环境搭建"></a>1 环境搭建</h3><ul>
<li><p>node.js 去官网下载安装即可</p>
</li>
<li><p>默认全局安装</p>
<p><code> npm install -g hexo-cli</code></p>
</li>
<li><p>Git 安装</p>
</li>
</ul>
<h3 id="2-创建项目-eqshen-github-io"><a href="#2-创建项目-eqshen-github-io" class="headerlink" title="2 创建项目  eqshen.github.io"></a>2 创建项目  eqshen.github.io</h3><p>创建命令并安装依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init eqshen.github.io</span><br><span class="line">cd eqshen.github.io</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h3 id="3-下载主题"><a href="#3-下载主题" class="headerlink" title="3 下载主题"></a>3 下载主题</h3><p>这里我使用的模板是 <a href="https://github.com/Shen-Yu/hexo-theme-ayer%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%E8%BF%99%E9%87%8C%E9%9D%A2%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E3%80%82">https://github.com/Shen-Yu/hexo-theme-ayer，也可以参考这里面的安装教程。</a></p>
<p>在 eqshen.github.io目录下执行命令,把主题下载下来</p>
<p><code>git clone https://github.com/Shen-Yu/hexo-theme-ayer.git themes/ayer</code></p>
<p>然后更新主题(刚下载下来应该是最新的，感觉这步可有可无)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd themes&#x2F;ayer</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>然后修改配置，eqshen.github.io/_config.yml</p>
<p><code>theme: ayer</code></p>
<h3 id="4-安装必须插件"><a href="#4-安装必须插件" class="headerlink" title="4 安装必须插件"></a>4 安装必须插件</h3><ul>
<li>搜索插件</li>
</ul>
<p><code>npm install hexo-generator-searchdb --save</code></p>
<p>然后在根目录下 _config.yml中添加以下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hexo-generator-searchdb</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br></pre></td></tr></table></figure>

<ul>
<li>RSS插件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>

<p>同样将下面代码复制到你项目根目录下的 _config.yml中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feed:</span><br><span class="line">    type: atom</span><br><span class="line">    path: atom.xml</span><br><span class="line">    limit: 20</span><br><span class="line">    hub:</span><br><span class="line">    content:</span><br><span class="line">    content_limit: 140</span><br><span class="line">    content_limit_delim: &#39; &#39;</span><br><span class="line">    order_by: -date</span><br></pre></td></tr></table></figure>

<p>这样项目的基本插件就安装完毕，而且依赖信息都会自动加入到你项目根目下的package.json中，下次直接npm install就可以了（nodejs包管理~~）</p>
<h3 id="5-添加菜单"><a href="#5-添加菜单" class="headerlink" title="5 添加菜单"></a>5 添加菜单</h3><p>由于使用了主题theme,所以修改菜单应该在 theme/ayer/_config.yml中修改，主页的标题副标题等都是改这里</p>
<p>修改下面这段代码对应的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  主页: &#x2F;</span><br><span class="line">  归档: &#x2F;archives</span><br><span class="line">  分类: &#x2F;categories</span><br><span class="line">  标签: &#x2F;tags</span><br><span class="line">  关于我: &#x2F;sys&#x2F;aboutMe</span><br></pre></td></tr></table></figure>

<p>/archives是默认的不需要改，/categories应该对应你项目下<code>/source/categories/</code> 目录，这时你会发现目录根本不存在，咋整？盘它。</p>
<p>执行命令创建目录,命令行执行前应该要切换到你项目的（根）目录，我这里是 <code>cd ~/workspace/eqshen.github.io/</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>然后修改配置  source/categories/index.md中的内容，替换为以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>



<p>然后再同样生成tag目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>同样修改配置  source/tags/index.md内容，替换为下面内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">layout: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>



<p>这样就大功告成，这里你可能会疑问，上面的命令是什么意思？hexo创建文章、目录、tag等是不用你 ‘右键-&gt;新建文件’这种操作的，只需要执行具体的命令，就可以替代上述操作，具体有哪些命令可以看这里 ：<a href="https://hexo.io/zh-cn/docs/commands">指令</a></p>
<h3 id="6-本地启动"><a href="#6-本地启动" class="headerlink" title="6 本地启动"></a>6 本地启动</h3><p>命令<code>hexo server</code></p>
<p>然后就可以到 localhost:4000 查看了</p>
<h3 id="7-部署"><a href="#7-部署" class="headerlink" title="7 部署"></a>7 部署</h3><p>本次的博客包括评论（gitalk）都上放在github仓库里的（免费的），部署方式可以采用hexo官方推荐的travis。不过我采用了 GitHub Action的方式，博客源码放在仓库<a href="https://github.com/eqshen/eqshen.github.io">eqshen.github.io</a>的develop分支上，编译后的前端代码放在该仓库的master分支。Github Action的脚本监听的是dep分支，即每次更新完博客，把源码推送到dep分支，博客就会自动编译并部署。配置步骤如下</p>
<ol>
<li><p>前提要创建好自己的仓库 xxx.github.io，其中xxx就是github用户名，如果还没了解过，先去百度吧，关键字：Github Page。</p>
</li>
<li><p>在仓库的Actions标签页下点击<code>New workflow</code>创建自动部署脚本，然后点击右上角 <code>skip this:Set up a workflow yourself</code>，然后就上写脚本了，写好脚本点右上角 <code>Start Commit</code>按钮就会在你项目的根目录下生成.github文件夹和相关文件。</p>
</li>
<li><p>上面的脚本当然不用自己写，站在巨人肩膀上，我们直接使用的是  <a href="renzhaosy/hexo-deploy-action">renzhaosy/hexo-deploy-action</a>。当然，如果你看了还是不懂，你可以直接复制我的脚本（我勉强让你踩一下我的肩膀~~）, 如果你有想法，比如监听的分支不是<code>dep</code>你可以自己改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: Build and Deploy</span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - dep</span><br><span class="line">jobs:</span><br><span class="line">  build-and-deploy:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">    - name: Checkout</span><br><span class="line">      uses: actions&#x2F;checkout@master</span><br><span class="line"></span><br><span class="line">    - name: Build and Deploy</span><br><span class="line">      uses: renzhaosy&#x2F;hexo-deploy-action@master</span><br><span class="line">      env:</span><br><span class="line">        PERSONAL_TOKEN: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;</span><br><span class="line">        PUBLISH_REPOSITORY: eqshen&#x2F;eqshen.github.io # The repository the action should deploy to.</span><br><span class="line">        BRANCH: master  # The branch the action should deploy to.</span><br><span class="line">        PUBLISH_DIR: .&#x2F;public # The folder the action should deploy.</span><br></pre></td></tr></table></figure>
</li>
<li><p>到这你就快成功了，接下来给上面脚本 创建 access_token（不然你的脚本可没有权限动你仓库的代码），看到上面脚本里的 <code>$&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;</code>了吗？像不像占位符，在执行的时候等待被替换呢！</p>
<ul>
<li>点击你github主页右上角的头像，再点击Setting，进入设置。</li>
<li>点击左侧菜单栏最后一项 <code>Develop Settings</code></li>
<li>然后点击 <code>Personal access token</code></li>
<li>再点击 <code>Generate new token</code>，然后按需求勾选赋予权限（理论上只要勾repo就行了，反正我除了delete的都勾了）</li>
<li>最后应该是点击最下面的<code>Generate Token</code>, 然后你就会拿到一个 access_token，复制这个token,页面先别关，关了这个token就找不到了,拿到这个token之后并不是去替换上面脚本里的<code>secrets.ACCESS_TOKEN</code></li>
<li>浏览器新打开一个标签页，进入你仓库的主页  xxx.github.io。点击仓库的的Settings，然后再点击<code>Secrets</code> -&gt; <code>Add a new secret</code>, Name填 <code>ACCESS_TOKEN</code>（跟脚本里的要一致，懂了吧？你仔细品），Value填上面生成的让你复制的那个 <code>access_token</code>，然后点击确定。</li>
<li>最后你往你脚本监听的分支推送源代码，然后点击 <code>Actions</code> 查看构建日志吧，可能要一分钟才能构建好。</li>
</ul>
</li>
<li><p>到此部署结束，还没弄图床，有空把上面几个关键步骤的图配了~~，有问题欢迎下方留言交流。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>hexo博客</tag>
        <tag>构建指南</tag>
      </tags>
  </entry>
  <entry>
    <title>一次Http未设置超时导致的线程假死阻塞</title>
    <url>/2020/04/11/http-thread-block-problem/</url>
    <content><![CDATA[<h2 id="故事开始"><a href="#故事开始" class="headerlink" title="故事开始"></a>故事开始</h2><p>某一天，我正在开开心心的写BUG，突然工作群里 @苟且偷生的BUG猿….我一看，这不是我嘛，再一看问题：xxx这笔订单怎么流程走到一半就终止了？快看看是啥问题。</p>
<h2 id="初步排查"><a href="#初步排查" class="headerlink" title="初步排查"></a>初步排查</h2><p>我一看这问题，难道报错了？没收到预警啊…迅速打开生产日志，一顿操作<code>cd ,ls,less,?,ctrl+c,ctrl+v,n</code>,终于找到这笔订单的遗言：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Order-xxxxx007 开始处理</span><br><span class="line"> ...</span><br><span class="line">Order-xxxxx007 风险评估 ....</span><br><span class="line">...</span><br><span class="line">Order-xxxxx007 调用Third-Api-X接口</span><br></pre></td></tr></table></figure>

<p>没有<code>Exception</code> ，惊喜不？意外不？果断打开吃饭工具IDEA,定位到代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();      </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * ...此处略去n行bug</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">executorService.submit(() -&gt; &#123;</span><br><span class="line">	<span class="comment">//调用三方api X</span></span><br><span class="line">	invokeThirdApi();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//....</span></span><br></pre></td></tr></table></figure>

<p>这？黑人抬棺的节奏，这什么鬼？线程跑到一半死了？所有流程中断了？怎么会这样。。一幅动图渐渐渗透到我的脑海里…</p>
<img src="https://i.loli.net/2020/04/11/1APBuLXqSk49Ggh.gif" alt="黑人" style="zoom:67%;" />

<p>再看下invokeThirdAPi，发现里面就postJson发送了一个http请求，不应该啊？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">postJson</span><span class="params">(String url,String data)</span></span>&#123;</span><br><span class="line">        HttpRequest httpRequest = cn.hutool.http.HttpUtil.createPost(url);</span><br><span class="line">        httpRequest.header(Header.CONTENT_TYPE,<span class="string">&quot;application/json;charset=UTF-8&quot;</span>).body(data);</span><br><span class="line">        HttpResponse response = httpRequest.execute();</span><br><span class="line">        <span class="keyword">return</span> response.body();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>咦？怎么http调用没有返回结果？http请求没有设置超时时间，第三方接口因为某些异常原因一直没有返回结果！线程一直被占用阻塞！</p>
<h2 id="初步得出的错误结论"><a href="#初步得出的错误结论" class="headerlink" title="初步得出的错误结论"></a>初步得出的错误结论</h2><p>仔细看了一下中的线程id： <code>[04-09 18:40:15,477] INFO [Thread-4-pool-1329] ...</code></p>
<p>再看看 一小时前的（一小时前发版服务重启过）<code>[04-09 17:00:15,472] INFO [Thread-4-pool-10] ...</code></p>
<p>一个小时线程id从10到1300+，按照现在的qps，50个线程都吃不完啊，阻塞这么多线程？恐慌，担忧😟，不知道黑人抬棺费用高不高，给自己也预约一个吧….</p>
<p>##真正的原因</p>
<p><code>.......few minutes later........</code></p>
<p>正在收拾行李的我（别问，问就是跑路），不对啊，我用的是 <code>Executors.newCachedThreadPool()</code>,默认情况下，线程空闲了会销毁的吧？正常销毁了再new出来，线程id是会自增的吧？？？上源码！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这？这些参数好熟悉又好陌生啊。。。好吧，拿起的我小本本找找…嗯，有了。</p>
<ul>
<li><p>int corePoolSize  该线程池中<strong>核心线程数最大值</strong></p>
<blockquote>
<p>核心线程，无论有没有任务，都不会被销毁（国企待遇啊），当然，设置了allowCoreThreadTimeOut(true)之后，也是可以被销毁的。</p>
</blockquote>
</li>
<li><p>int maximumPoolSize 该线程池中<strong>线程总数最大值</strong> </p>
<blockquote>
<p>该值等于核心线程数量 + 非核心线程数量。</p>
</blockquote>
</li>
<li><p>long keepAliveTime <strong>非核心线程闲置超时时长</strong></p>
</li>
<li><p>TimeUnit unit  keepAliveTime的单位</p>
</li>
<li><p>BlockingQueue workQueue 阻塞队列，维护着<strong>等待执行的Runnable任务对象</strong>,也就是任务队列。</p>
<p>有以下几种实现</p>
<ul>
<li>LinkedBlockingQueue</li>
<li>ArrayBlockingQueue</li>
<li>SynchronousQueue  同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然</li>
<li>DelayQueue 延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 </li>
</ul>
</li>
<li><p>ThreadFactory threadFactory 创建线程的工厂 ，用于批量创建线程。</p>
</li>
<li><p>RejectedExecutionHandler handler 拒绝策略，此处不展开</p>
</li>
</ul>
<p>更多关于线程池的资料 看这里 <a href="https://redspider.gitbook.io/concurrent/di-san-pian-jdk-gong-ju-pian/12">gitbook-线程池</a></p>
<p>然后，咱们再回头看看 newCachedThreadPool，这是人干的事吗？</p>
<ul>
<li>核心线程数为 0</li>
<li>非核心线程数不限，但存活时间  60 秒</li>
</ul>
<p>那么上面这些参数到底是怎么运转的呢？看图</p>
<img src="https://i.loli.net/2020/04/11/e3y69UpSxah1nu4.jpg" alt="流程图" style="zoom:80%;" />



<p>再看下 ThreadFactory <code>Executors.defaultThreadFactory()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        DefaultThreadFactory() &#123;</span><br><span class="line">            SecurityManager s = System.getSecurityManager();</span><br><span class="line">            group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                                  Thread.currentThread().getThreadGroup();</span><br><span class="line">            namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                          poolNumber.getAndIncrement() +</span><br><span class="line">                         <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                                  namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                                  <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">                t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>Thread t = new Thread(group, r,namePrefix + threadNumber.getAndIncrement(),0);</code></p>
<p>所以：正常的销毁创建也会id自增，这我就放心了。。。</p>
<h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><ul>
<li><p>设置http超时</p>
</li>
<li><p>更换自定义线程池（定制化的才是最好的）</p>
<p>ThreadPoolTaskExecutor 是spring提供的，是对 ThreadPoolExecutor的封装。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;thirdApiExecutor&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title">thirdApiExecutor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ThreadPoolTaskExecutor taskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">    taskExecutor.setCorePoolSize(<span class="number">20</span>);</span><br><span class="line">    taskExecutor.setMaxPoolSize(<span class="number">40</span>);</span><br><span class="line">    taskExecutor.setKeepAliveSeconds(<span class="number">300</span>);</span><br><span class="line">    taskExecutor.setAllowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">    taskExecutor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">    taskExecutor.setAwaitTerminationSeconds(<span class="number">10</span>);</span><br><span class="line">    taskExecutor.setQueueCapacity(<span class="number">200</span>);</span><br><span class="line">    taskExecutor.setThreadNamePrefix(<span class="string">&quot;ThirdApi-Executor-&quot;</span>);</span><br><span class="line">    taskExecutor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">    <span class="keyword">return</span> taskExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>线程内的 http等IO阻塞行为一定要设置timeout。</li>
<li>自定义线程池，根据业务场景和特点设置参数。</li>
<li>平时基本功要扎实，不然翻小本本也挺浪费时间，特别是生产环境出问题了，都是比较急的，没有多少时间给你去学习和查找资料，所以平时要多积累。</li>
</ul>
<h2 id="到这就完了？就这？"><a href="#到这就完了？就这？" class="headerlink" title="到这就完了？就这？"></a>到这就完了？就这？</h2><p><strong>到现在，我还有一个最大的疑问：如何确定目前生产环境是否存在被永久阻塞在IO上的线程？</strong></p>
<h2 id="Java线程状态"><a href="#Java线程状态" class="headerlink" title="Java线程状态"></a>Java线程状态</h2><p>到这里我们就需要知道 Java线程在生命周期中存在哪些状态了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Thread.State 源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体每个状态的意义以及状态的转换场景看这里 <a href="https://redspider.gitbook.io/concurrent/di-yi-pian-ji-chu-pian/4">Java线程状态及主要转化方法</a></p>
<h2 id="复现事故现场"><a href="#复现事故现场" class="headerlink" title="复现事故现场"></a>复现事故现场</h2><h3 id="再次分析"><a href="#再次分析" class="headerlink" title="再次分析"></a>再次分析</h3><p>文中也多次提到”阻塞“关键字，那永久等待Http 响应的那个线程应该是什么状态呢？？首先猜想是<code>Blocked</code>,但按照理论来讲，只有等待锁的线程才会是Blocked状态，使用排除法，我最终猜想它是<code>Runnable</code>状态，下面就来证实一下。</p>
<h3 id="代码复现"><a href="#代码复现" class="headerlink" title="代码复现"></a>代码复现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testThreadBlock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//模拟调用三方api</span></span><br><span class="line">            invokeThirdApi();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加一个其他任务</span></span><br><span class="line">        executorService.submit(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">               log.info(<span class="string">&quot;线程 &#123;&#125; 正在干活&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">               Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">				<span class="comment">//让主线程在此休息</span></span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">invokeThirdApi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        InputStream is = System.in;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(is);</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125; IO输入开始&quot;</span>,threadName);</span><br><span class="line">        String input =  scanner.next();</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125; IO输入结束：&#123;&#125;&quot;</span>,threadName,input);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>简单解释一下上面程序：</p>
<ul>
<li><p>基于junit测试的方式</p>
</li>
<li><p>testThreadBlock方法中定义一个线程池<code>newCachedThreadPool</code>,然后向线程池提交了两个任务</p>
<ul>
<li>第一个是一次性调用三方接口的任务</li>
<li>第二个是一个重复执行的任务</li>
</ul>
</li>
<li><p>调用三方接口，这里使用<code>Scanner</code>监听终端输入来模拟（当然也可以自己本地启一个测试项目，暴露一个接口，然后接口逻辑中打个断点，这样在http请求的时候被断点卡住就行了）</p>
</li>
</ul>
<p>看一下程序运行的日志：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">11</span> <span class="number">19</span>:<span class="number">14</span>:<span class="number">56</span><span class="variable">.852</span>  INFO <span class="number">27281</span> --- [pool-<span class="number">1</span>-thread-<span class="number">1</span>] com<span class="variable">.eqshen</span><span class="variable">.springdemo</span><span class="variable">.ThreadPoolTest</span>     : pool-<span class="number">1</span>-thread-<span class="number">1</span> IO输入开始</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">11</span> <span class="number">19</span>:<span class="number">14</span>:<span class="number">56</span><span class="variable">.850</span>  INFO <span class="number">27281</span> --- [pool-<span class="number">1</span>-thread-<span class="number">2</span>] com<span class="variable">.eqshen</span><span class="variable">.springdemo</span><span class="variable">.ThreadPoolTest</span>     : 线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 正在干活</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">11</span> <span class="number">19</span>:<span class="number">14</span>:<span class="number">59</span><span class="variable">.858</span>  INFO <span class="number">27281</span> --- [pool-<span class="number">1</span>-thread-<span class="number">2</span>] com<span class="variable">.eqshen</span><span class="variable">.springdemo</span><span class="variable">.ThreadPoolTest</span>     : 线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 正在干活</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">11</span> <span class="number">19</span>:<span class="number">15</span>:<span class="number">02</span><span class="variable">.861</span>  INFO <span class="number">27281</span> --- [pool-<span class="number">1</span>-thread-<span class="number">2</span>] com<span class="variable">.eqshen</span><span class="variable">.springdemo</span><span class="variable">.ThreadPoolTest</span>     : 线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 正在干活</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">11</span> <span class="number">19</span>:<span class="number">15</span>:<span class="number">05</span><span class="variable">.865</span>  INFO <span class="number">27281</span> --- [pool-<span class="number">1</span>-thread-<span class="number">2</span>] com<span class="variable">.eqshen</span><span class="variable">.springdemo</span><span class="variable">.ThreadPoolTest</span>     : 线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 正在干活</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">11</span> <span class="number">19</span>:<span class="number">15</span>:<span class="number">08</span><span class="variable">.867</span>  INFO <span class="number">27281</span> --- [pool-<span class="number">1</span>-thread-<span class="number">2</span>] com<span class="variable">.eqshen</span><span class="variable">.springdemo</span><span class="variable">.ThreadPoolTest</span>     : 线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 正在干活</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">11</span> <span class="number">19</span>:<span class="number">15</span>:<span class="number">11</span><span class="variable">.870</span>  INFO <span class="number">27281</span> --- [pool-<span class="number">1</span>-thread-<span class="number">2</span>] com<span class="variable">.eqshen</span><span class="variable">.springdemo</span><span class="variable">.ThreadPoolTest</span>     : 线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 正在干活</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">11</span> <span class="number">19</span>:<span class="number">15</span>:<span class="number">14</span><span class="variable">.875</span>  INFO <span class="number">27281</span> --- [pool-<span class="number">1</span>-thread-<span class="number">2</span>] com<span class="variable">.eqshen</span><span class="variable">.springdemo</span><span class="variable">.ThreadPoolTest</span>     : 线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 正在干活</span><br></pre></td></tr></table></figure>

<p>可以发现thread-1启动之后直接就被阻塞了</p>
<h3 id="使用jstack"><a href="#使用jstack" class="headerlink" title="使用jstack"></a>使用jstack</h3><p>下面就使用jstack查看一下线程的真正状态</p>
<p>使用<code>jps</code>命令查看进程id</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">27281 JUnitStarter</span><br><span class="line">20500</span><br><span class="line">27285 Jps</span><br><span class="line">26586 RemoteMavenServer</span><br><span class="line">27279 Launcher</span><br></pre></td></tr></table></figure>

<p>然后执行命令 <code>jstack 27281 &gt; test.jstack</code></p>
<p>到 test.jstack中间中按照关键字搜索 <code>pool-1-thread-1</code>会找到如下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&quot;pool-1-thread-1&quot; #19 prio=5 os_prio=31 cpu=2.46ms elapsed=215.35s tid=0x00007fddfabf0000 nid=0x6703 runnable  [0x0000700007286000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.io.FileInputStream.readBytes(java.base@<span class="number">11.0</span>.<span class="number">2</span>/Native Method)</span><br><span class="line">        at java.io.FileInputStream.read(java.base@<span class="number">11.0</span>.<span class="number">2</span>/FileInputStream.java:<span class="number">279</span>)</span><br><span class="line">        at java.io.BufferedInputStream.read1(java.base@<span class="number">11.0</span>.<span class="number">2</span>/BufferedInputStream.java:<span class="number">290</span>)</span><br><span class="line">        at java.io.BufferedInputStream.read(java.base@<span class="number">11.0</span>.<span class="number">2</span>/BufferedInputStream.java:<span class="number">351</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x0000000700133178</span>&gt; (a java.io.BufferedInputStream)</span><br><span class="line">        at sun.nio.cs.StreamDecoder.readBytes(java.base@<span class="number">11.0</span>.<span class="number">2</span>/StreamDecoder.java:<span class="number">284</span>)</span><br><span class="line">        at sun.nio.cs.StreamDecoder.implRead(java.base@<span class="number">11.0</span>.<span class="number">2</span>/StreamDecoder.java:<span class="number">326</span>)</span><br><span class="line">        at sun.nio.cs.StreamDecoder.read(java.base@<span class="number">11.0</span>.<span class="number">2</span>/StreamDecoder.java:<span class="number">178</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x000000070aa0fef0</span>&gt; (a java.io.InputStreamReader)</span><br><span class="line">        at java.io.InputStreamReader.read(java.base@<span class="number">11.0</span>.<span class="number">2</span>/InputStreamReader.java:<span class="number">185</span>)</span><br><span class="line">        at java.io.Reader.read(java.base@<span class="number">11.0</span>.<span class="number">2</span>/Reader.java:<span class="number">189</span>)</span><br><span class="line">        at java.util.Scanner.readInput(java.base@<span class="number">11.0</span>.<span class="number">2</span>/Scanner.java:<span class="number">882</span>)</span><br><span class="line">        at java.util.Scanner.next(java.base@<span class="number">11.0</span>.<span class="number">2</span>/Scanner.java:<span class="number">1476</span>)</span><br><span class="line">        at com.eqshen.springdemo.ThreadPoolTest.invokeThirdApi(ThreadPoolTest.java:<span class="number">44</span>)</span><br><span class="line">        at com.eqshen.springdemo.ThreadPoolTest.lambda$testThreadBlock$<span class="number">0</span>(ThreadPoolTest.java:<span class="number">25</span>)</span><br><span class="line">        at com.eqshen.springdemo.ThreadPoolTest$$Lambda$<span class="number">767</span>/<span class="number">0x0000000800568440.</span>run(Unknown Source)</span><br><span class="line">        at java.util.concurrent.Executors$RunnableAdapter.call(java.base@<span class="number">11.0</span>.<span class="number">2</span>/Executors.java:<span class="number">515</span>)</span><br><span class="line">        at java.util.concurrent.FutureTask.run$$$capture(java.base@<span class="number">11.0</span>.<span class="number">2</span>/FutureTask.java:<span class="number">264</span>)</span><br><span class="line">        at java.util.concurrent.FutureTask.run(java.base@<span class="number">11.0</span>.<span class="number">2</span>/FutureTask.java)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@<span class="number">11.0</span>.<span class="number">2</span>/ThreadPoolExecutor.java:<span class="number">1128</span>)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@<span class="number">11.0</span>.<span class="number">2</span>/ThreadPoolExecutor.java:<span class="number">628</span>)</span><br><span class="line">        at java.lang.Thread.run(java.base@<span class="number">11.0</span>.<span class="number">2</span>/Thread.java:<span class="number">834</span>)</span><br></pre></td></tr></table></figure>

<p>可以看出线程状态和我们猜想的是一致的：RUNNABLE</p>
<h3 id="递归懵逼"><a href="#递归懵逼" class="headerlink" title="递归懵逼"></a>递归懵逼</h3><p>那现在如何在茫茫程海中定位到这种问题？？？</p>
<blockquote>
<p>“pool-1-thread-1” #19 prio=5 os_prio=31 cpu=2.46ms elapsed=215.35s tid=0x00007fddfabf0000 nid=0x6703 runnable  [0x0000700007286000]</p>
</blockquote>
<p>如果多次执行jstack，发现 <code>cpu=2.46ms</code> 值是不变的（IO阻塞了，永远不会再被分配到cpu时间片，当然不变了），这也是我目前能想到的办法☹️</p>
]]></content>
      <categories>
        <category>BUG</category>
        <category>线程</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>HTTP</tag>
        <tag>BUG</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的缓存算法及动手实现</title>
    <url>/2020/04/06/lru-lfu-cache/</url>
    <content><![CDATA[<h1 id="常见的缓存算法及动手实现"><a href="#常见的缓存算法及动手实现" class="headerlink" title="常见的缓存算法及动手实现"></a>常见的缓存算法及动手实现</h1><ul>
<li>FIFO 先进先出 - First In First Out.</li>
<li>LRU 最近最少使用 - Least Recently Used.</li>
<li>LFU 最不经常使用 - Least Frequently Used.</li>
</ul>
<h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><ul>
<li>使用队列实现，新增数据从队尾插入，淘汰数据从队头出队。</li>
</ul>
<h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><h4 id="核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”"><a href="#核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”" class="headerlink" title="核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”"></a>核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”</h4><h4 id="一个操作demo"><a href="#一个操作demo" class="headerlink" title="一个操作demo"></a>一个操作demo</h4><ol>
<li><p>LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );</p>
</li>
<li><p>cache.put(1, 1);</p>
</li>
<li><p>cache.put(2, 2);</p>
</li>
<li><p>cache.get(1);       // 返回  1</p>
</li>
<li><p>cache.put(3, 3);    // 该操作会使得key=2 作废</p>
</li>
<li><p>cache.get(2);       // 返回 -1 (未找到)</p>
</li>
<li><p>cache.put(4, 4);    // 该操作会使得key=1 作废</p>
</li>
<li><p>cache.get(1);       // 返回 -1 (未找到)</p>
</li>
<li><p>cache.get(3);       // 返回  3</p>
</li>
<li><p>cache.get(4);       // 返回  4</p>
</li>
</ol>
<h4 id="如何实现这样一个数据结构？一个高效的缓存应该具有以下特点"><a href="#如何实现这样一个数据结构？一个高效的缓存应该具有以下特点" class="headerlink" title="如何实现这样一个数据结构？一个高效的缓存应该具有以下特点"></a>如何实现这样一个数据结构？一个高效的缓存应该具有以下特点</h4><ul>
<li><p>两个方法put(k,v)和get(k)</p>
</li>
<li><p>时间复杂度，空间复杂度越低越好，最好是O(1)</p>
</li>
<li><p>需要保存每个元素的访问顺序，每次被访问到，就把元素移动到末尾，这里需要链表结构</p>
</li>
<li><p>同时还需要hash结构还保证每次查找的O(1)复杂度</p>
</li>
<li><p>所以我们需要的是  HashMap + 链表的结合体，在JAVA恰好有LinkedHashMap这种数据结构</p>
</li>
</ul>
<h4 id="LinkedHashMap源码分析"><a href="#LinkedHashMap源码分析" class="headerlink" title="LinkedHashMap源码分析"></a>LinkedHashMap源码分析</h4><p>在真正动手实现之前我们不妨先看看LinkedHashMap是否满足我们的需求。</p>
<p>先来看看构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里的 accessOrder 默认是为false，如果要按读取顺序排序需要将其设为 true</span></span><br><span class="line"><span class="comment">// initialCapacity 代表 map 的 容量，loadFactor 代表加载因子 (默认即可)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>accessOrder决定了链表中结点的排序方式</p>
<ul>
<li>false :  按照插入顺序排序</li>
<li>True：按照读取顺序排序</li>
</ul>
<p>显然，这并不满足我们的需求啊，在LRU中插入/读取都算入“访问”的（从上面的demo就可以看出）</p>
<p>莫方，我们继续看看源码，看看能不能稍加修改为我所用。然后我们就找到了下面三个方法，用于改变结点顺序的。</p>
<ul>
<li><strong>void afterNodeRemoval(Node p) { }</strong>  结点删除后，把对应的数据从链表中删除</li>
<li><strong>void afterNodeAccess(Node p) { }</strong> 其作用就是在访问元素之后，将该元素放到双向链表的尾巴处(只有读操作时才会调用）并且在accessOrder = true才生效~~</li>
<li><strong>void afterNodeInsertion(boolean evict) { }</strong>  这个貌似是我们的重点啊，我们现在需要的就是把insert也算入“访问”操作，那看看其源码吧</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//evict中文意思驱逐，应该是用来控制是否执行删除的一个因素，通过源码追踪，发现只有readObject反序列化的时候才为false,其他时候都为true,所以可以认为这个值始终为true</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">        <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">            K key = first.key;</span><br><span class="line">            removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再来看看<code>removeEldestEntry</code>这个方法是有什么用，上源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> * &lt;p&gt;This method typically does not modify the map in any way,</span><br><span class="line"> * instead allowing the map to modify itself as directed by its</span><br><span class="line"> * return value.  It &lt;i&gt;is&lt;/i&gt; permitted for this method to modify</span><br><span class="line"> * the map directly, but if it does so, it &lt;i&gt;must&lt;/i&gt; return</span><br><span class="line"> * &#123;<span class="meta">@code</span> <span class="keyword">false</span>&#125; (indicating that the map should not attempt any</span><br><span class="line"> * further modification).  The effects of returning &#123;<span class="meta">@code</span> <span class="keyword">true</span>&#125;</span><br><span class="line"> * after modifying the map from within <span class="keyword">this</span> method are unspecified.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This implementation merely returns &#123;<span class="meta">@code</span> <span class="keyword">false</span>&#125; (so that <span class="keyword">this</span></span><br><span class="line"> * map acts like a normal map - the eldest element is never removed).</span><br><span class="line"> *</span><br><span class="line"> * <span class="meta">@param</span>    eldest The least recently inserted entry in the map, or <span class="keyword">if</span></span><br><span class="line"> *           <span class="keyword">this</span> is an access-ordered map, the least recently accessed</span><br><span class="line"> *           entry.  This is the entry that will be removed it <span class="keyword">this</span></span><br><span class="line"> *           method returns &#123;<span class="meta">@code</span> <span class="keyword">true</span>&#125;.  If the map was empty prior</span><br><span class="line"> *           to the &#123;<span class="meta">@code</span> put&#125; or &#123;<span class="meta">@code</span> putAll&#125; invocation resulting</span><br><span class="line"> *           in <span class="keyword">this</span> invocation, <span class="keyword">this</span> will be the entry that was just</span><br><span class="line"> *           inserted; in other words, <span class="keyword">if</span> the map contains a single</span><br><span class="line"> *           entry, the eldest entry is also the newest.</span><br><span class="line"> * <span class="meta">@return</span>   &#123;<span class="meta">@code</span> <span class="keyword">true</span>&#125; <span class="keyword">if</span> the eldest entry should be removed</span><br><span class="line"> *           from the map; &#123;<span class="meta">@code</span> <span class="keyword">false</span>&#125; <span class="keyword">if</span> it should be retained.</span><br><span class="line"> */</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>函数很简单，但是我特意复制了很长英文注释（保留原汁原味的嘛），意思是这个函数是一个策略函数，用来决定是否移除“最老”的元素，默认是<code>false</code>。而我们要实现LRU，当缓存满的时候，必须要移除最老的元素，也就是队头的元素。所以，Override之</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单易懂</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> size() &gt; capacity; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>完整的LRU源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//缓存的容量大小</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75F</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">//如果缓存不存在，返回null或者自定义一个默认值，此处为-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// put 操作很简单，直接叫爸爸就完事儿了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>就这？没错，就这么简单，因为你站在了巨人的肩膀上~~，当然你也可以从0开始实现。这里就暂时偷懒，插个眼，想进一步了解，看这里 <a href="https://leetcode-cn.com/problems/lru-cache/solution/">力扣LRU</a></p>
<h3 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h3><ul>
<li>核心思想是“如果数据过去被访问数次越多，那么将来被访问的频率也更高”。</li>
</ul>
<h4 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h4><ul>
<li>每个元素需要按照访问次数（频率）排序，当缓存满了，移除访问次数最少的那个；</li>
<li>如果缓存中的访问频率都一样，那就移除最近最少使用的（没错，就变成了LRU了）</li>
<li>get 方法，需要支持O(1)级别的快速查找，考虑了一下果断hash啊</li>
<li>put方法，最好也支持O(1)级别的，果断用链表啊</li>
</ul>
<h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>LFUCache cache = new LFUCache( 2 );  //2为capacity，缓存容量</p>
<p>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // 返回 1<br>cache.put(3, 3);    // 去除 key 2<br>cache.get(2);       // 返回 -1 (未找到key 2)<br>cache.get(3);       // 返回 3<br>cache.put(4, 4);    // 去除 key 1，此时3和1的访问次数都是2，但1比3来的早。<br>cache.get(1);       // 返回 -1 (未找到 key 1)<br>cache.get(3);       // 返回 3<br>cache.get(4);       // 返回 4</p>
<h4 id="动手实现"><a href="#动手实现" class="headerlink" title="动手实现"></a>动手实现</h4><p>采用HashMap和 LinkedHashSet强强联合的方式实现。原理可以看下图(引用自<a href="https://leetcode-cn.com/problems/lfu-cache/solution/ha-xi-biao-shuang-xiang-lian-biao-java-by-liweiwei/">LeetCode题解)</a></p>
<p><img src="https://pic.leetcode-cn.com/909ea661e76e600e49763d06d2fa72b7897e36ebf47d966292636bce1b241734-image.png"></p>
<p>从上图可以看出，我们需要啥？假设我们缓存的key,value类型都是Integer</p>
<ul>
<li>一个HashMap&lt;Integer,Node&gt; cache;  Node是双向链表的结点类型</li>
<li>一个HashMap&lt;Integer,LinkedHashSet<Node>&gt; freqMap；一个记录访问次数的 hash表+双向链表结构，这里就使用JAVA自带的  LinkedHashSet。</li>
<li>新来的结点放在双向链表尾部，所以采用<code>尾插法</code>，没办法，谁让LinkedHashSet尾插效率高呢~~</li>
</ul>
<p>首先，定义Node结点结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">  	<span class="comment">//默认为1</span></span><br><span class="line">    <span class="keyword">int</span> freq = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后是，LFU类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer,Node&gt; cache;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer,LinkedHashSet&lt;Node&gt;&gt; freqMap;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 避免每次都要遍历freqMap，采用全局变量维护一个当前的最小频次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minFreq;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存最大容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.freqMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的功能需要我们一步一步完善它了。</p>
<p>首先看看 <code>get</code>方法，这个应该是最简单的。</p>
<ul>
<li>根据<code>key</code>从 <code>cache</code>中取出对应的结点Node，<ul>
<li>如果Node存在，则返回其值，并node.freq++;</li>
<li>不存在则返回默认值 null ,或者-1(根据业务需求，为了简单这里就 -1吧，实际应该是null,并且结合泛型来做)。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        Node node = <span class="keyword">this</span>.cache.get(key);</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="comment">//增加此结点的访问次数</span></span><br><span class="line">            <span class="keyword">this</span>.freqIncrement(node);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加结点的访问次数不仅仅是  <code>node.freq++</code>这么简单，我们要同步更新<code>this.freqMap</code>把Node移动到对应频次（调用次数的）桶里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加结点访问次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freqIncrement</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//找到旧的桶中的结点，并移除</span></span><br><span class="line">        <span class="keyword">int</span> curFreq = node.freq;</span><br><span class="line">        LinkedHashSet&lt;Node&gt; oldSet = <span class="keyword">this</span>.freqMap.get(curFreq);</span><br><span class="line">        oldSet.remove(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前桶移除了node后，已经是个空桶了，那么minFreq就要指向大一号的桶</span></span><br><span class="line">        <span class="keyword">if</span>(curFreq == minFreq &amp;&amp; oldSet.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            minFreq = curFreq + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//增加访问次数，并加入新桶的链尾</span></span><br><span class="line">        node.freq++;</span><br><span class="line">        LinkedHashSet&lt;Node&gt; newSet = <span class="keyword">this</span>.freqMap.get(node.freq);</span><br><span class="line">        <span class="keyword">if</span>(newSet == <span class="keyword">null</span>)&#123;</span><br><span class="line">            newSet = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.freqMap.put(node.freq,newSet);</span><br><span class="line">        &#125;</span><br><span class="line">        newSet.add(node);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>然后是<code>put</code>方法，这个方法就稍复杂一点了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//容量是0，那它可能是个假缓存吧</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.capacity == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node curNode = cache.get(key);</span><br><span class="line">        <span class="comment">//如果缓存已经存在，直接覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (curNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            curNode.value = value;</span><br><span class="line">            <span class="keyword">this</span>.freqIncrement(curNode);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//缓存容量达到上限了？需要先删除</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.cache.size() == capacity)&#123;</span><br><span class="line">                <span class="comment">//删除第一个</span></span><br><span class="line">                LinkedHashSet&lt;Node&gt; set = <span class="keyword">this</span>.freqMap.get(minFreq);</span><br><span class="line">                Node needRemove = set.iterator().next();</span><br><span class="line">                set.remove(needRemove);</span><br><span class="line">                cache.remove(needRemove);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//新增</span></span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">            cache.put(key,newNode);</span><br><span class="line">            LinkedHashSet&lt;Node&gt; floorDeq = <span class="keyword">this</span>.freqMap.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(floorDeq == <span class="keyword">null</span>)&#123;</span><br><span class="line">                floorDeq = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">                freqMap.put(<span class="number">1</span>,floorDeq);</span><br><span class="line">            &#125;</span><br><span class="line">            floorDeq.add(newNode);</span><br><span class="line">            <span class="comment">//更新minFreq</span></span><br><span class="line">            minFreq = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LFUCache cache = <span class="keyword">new</span> LFUCache(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(cache.getMap().keySet());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res1 = cache.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(res1);</span><br><span class="line"></span><br><span class="line">        cache.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(cache.getMap().keySet());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res2 = cache.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(res2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res3 = cache.get(<span class="number">3</span>);</span><br><span class="line">        System.out.println(res3);</span><br><span class="line"></span><br><span class="line">        cache.put(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(cache.getMap().keySet());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res4 = cache.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(res4);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res5 = cache.get(<span class="number">3</span>);</span><br><span class="line">        System.out.println(res5);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res6 = cache.get(<span class="number">4</span>);</span><br><span class="line">        System.out.println(res6);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>为了代码简单，上面能用java提供的集合类都尽量使用了，但是为了效率高，最好的办法是实现一个自己的双端链表来实现，但是生产环境不推荐自己实现LRU,LFU这种，直接用现成的。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><a href="https://leetcode-cn.com/problems/lfu-cache/solution/java-13ms-shuang-100-shuang-xiang-lian-biao-duo-ji/">LeetCode-Sweetiee甜姨</a></li>
<li><a href="https://leetcode-cn.com/problems/lfu-cache/solution/ha-xi-biao-shuang-xiang-lian-biao-java-by-liweiwei/">LeetCode-liwewei大佬</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
        <tag>FIFO</tag>
        <tag>LRU</tag>
        <tag>LFU</tag>
      </tags>
  </entry>
  <entry>
    <title>Java父子线程的ThreadLocal数据传递问题</title>
    <url>/2020/05/26/InheritableThreadLocal/</url>
    <content><![CDATA[<h2 id="JAVA父子线程之间如何传递数据"><a href="#JAVA父子线程之间如何传递数据" class="headerlink" title="JAVA父子线程之间如何传递数据"></a>JAVA父子线程之间如何传递数据</h2><h3 id="线程之间通信的方式"><a href="#线程之间通信的方式" class="headerlink" title="线程之间通信的方式"></a>线程之间通信的方式</h3><p>常见的方式由以下几种</p>
<ul>
<li>同步锁</li>
<li>通知等待机制：notify/wait</li>
<li>信号量 CountdownLatch/CyclicBarrier/Semaphore</li>
<li>管道PipedWriter/ PipedReader/ PipedOutputStream/ PipedInputStream</li>
</ul>
<p>当然，上面这些跟今天要讨论的东西没关系。</p>
<h3 id="父子线程ThreadLocal问题"><a href="#父子线程ThreadLocal问题" class="headerlink" title="父子线程ThreadLocal问题"></a>父子线程ThreadLocal问题</h3><p>首先看一段代码，提出问题:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadLocal&lt;String&gt; threadLocal = ThreadLocal.withInitial(()-&gt;&#123;<span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;&#125;);</span><br><span class="line">        threadLocal.set(<span class="string">&quot;modify hello world&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getId()+<span class="string">&quot; get:&quot;</span>+threadLocal.get());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;Thread:&quot;</span>+ Thread.currentThread().getId()+<span class="string">&quot; get:&quot;</span>+ threadLocal.get())).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;====end======&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码:父线程（main）线程定义了一个ThreadLocal变量，并定义了初始值。然后，启动多个子线程，在子线程中执行 <code>threadLocal.get()</code>那么根据threadLocal的特性，会拿到什么值呢？看输出：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> get:modify hello world</span><br><span class="line">Thread:<span class="number">13</span> get:hello world</span><br><span class="line">Thread:<span class="number">14</span> get:hello world</span><br><span class="line">Thread:<span class="number">15</span> get:hello world</span><br><span class="line">Thread:<span class="number">16</span> get:hello world</span><br><span class="line">Thread:<span class="number">17</span> get:hello world</span><br><span class="line">Thread:<span class="number">18</span> get:hello world</span><br><span class="line">Thread:<span class="number">19</span> get:hello world</span><br><span class="line">Thread:<span class="number">21</span> get:hello world</span><br><span class="line">Thread:<span class="number">20</span> get:hello world</span><br><span class="line">Thread:<span class="number">22</span> get:hello world</span><br><span class="line">====<span class="keyword">end</span>======</span><br></pre></td></tr></table></figure>

<p>这边我们可以得出两个结论</p>
<ol>
<li>ThreadLocal.withInitial设置的初始值其实就是默认值，所有线程都会影响到（看源码，SuppliedThreadLocal重写了initialValue方法 ）。</li>
<li>ThreadLocal实现数据的线程隔离。</li>
</ol>
<p>那么有没有办法可以实现兄弟线程之间数据隔离，但父子线程之间数据互通呢？</p>
<h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><p>InheritableThreadLocal可以实现数据的继承，但是继承之后，子线程修改threadLocal中的值是无法传递到父线程的，即这种数据传递是单向的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> InheritableThreadLocal();</span><br><span class="line">        threadLocal.set(<span class="string">&quot;modify hello world&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getId()+<span class="string">&quot; get:&quot;</span>+threadLocal.get());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread:&quot;</span>+ Thread.currentThread().getId()+<span class="string">&quot; get:&quot;</span>+ threadLocal.get());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;====end======&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> get:modify hello world</span><br><span class="line">Thread:<span class="number">13</span> get:modify hello world</span><br><span class="line">Thread:<span class="number">14</span> get:modify hello world</span><br><span class="line">Thread:<span class="number">15</span> get:modify hello world</span><br><span class="line">Thread:<span class="number">16</span> get:modify hello world</span><br><span class="line">Thread:<span class="number">17</span> get:modify hello world</span><br><span class="line">Thread:<span class="number">18</span> get:modify hello world</span><br><span class="line">Thread:<span class="number">19</span> get:modify hello world</span><br><span class="line">Thread:<span class="number">20</span> get:modify hello world</span><br><span class="line">Thread:<span class="number">21</span> get:modify hello world</span><br><span class="line">Thread:<span class="number">22</span> get:modify hello world</span><br><span class="line">====<span class="keyword">end</span>======</span><br></pre></td></tr></table></figure>

<p>那么这是怎么做到的呢？</p>
<p>查看源码，发现InheritableThreadLocal源码很简单，继承了ThreadLocal，重写了三个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes the child&#x27;s initial value for this inheritable thread-local</span></span><br><span class="line"><span class="comment">     * variable as a function of the parent&#x27;s value at the time the child</span></span><br><span class="line"><span class="comment">     * thread is created.  This method is called from within the parent</span></span><br><span class="line"><span class="comment">     * thread before the child is started.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This method merely returns its input argument, and should be overridden</span></span><br><span class="line"><span class="comment">     * if a different behavior is desired.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentValue the parent thread&#x27;s value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the child thread&#x27;s initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the map associated with a ThreadLocal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create the map associated with a ThreadLocal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue value for the initial entry of the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点关注 childValue 这个方法，注释大概意思是：这个方法会在父线程创建子线程的时候被调用，子线程创建的时候，inheritableThreadLocals这个map要把父线程的inheritableThreadLocals 中的所有k,v拷贝过来，拷贝的时候，每个entry的value是否需要重新计算呢？childValue就是负责重新计算的，只不过默认的实现是返回传入参数，do nothing。</p>
<p>继续追踪一下调用链路，验证上面的说法，看看childValue被谁调用了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Construct a new map including all Inheritable ThreadLocals</span></span><br><span class="line"><span class="comment">         * from given parent map. Called only by createInheritedMap.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> parentMap the map associated with parent thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">            Entry[] parentTable = parentMap.table;</span><br><span class="line">            <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">            setThreshold(len);</span><br><span class="line">            table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Entry e : parentTable) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">                    <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Object value = key.childValue(e.value);</span><br><span class="line">                        Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                        <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                            h = nextIndex(h, len);</span><br><span class="line">                        table[h] = c;</span><br><span class="line">                        size++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这个是ThreadLocal类的一个private构造方法，从功能上看，就是拷贝传进来的threadLocalMap的内容，从注释上看，这个构造函数的调用是：<code>Called only by createInheritedMap</code>,看一下上一层调用的地方</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续追上层调用，就会跳到Thread的源码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Thread</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">        Thread parent = currentThread();</span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Determine if it&#x27;s an applet or not */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">               what to do. */</span></span><br><span class="line">            <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">                g = security.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If the security manager doesn&#x27;t have a strong opinion</span></span><br><span class="line"><span class="comment">               on the matter, use the parent thread group. */</span></span><br><span class="line">            <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">                g = parent.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class="line"><span class="comment">           explicitly passed in. */</span></span><br><span class="line">        g.checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Do we have the required permissions?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">                security.checkPermission(</span><br><span class="line">                        SecurityConstants.SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g.addUnstarted();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.group = g;</span><br><span class="line">        <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">        <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">        <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">            <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">        <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">                acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        setPriority(priority);</span><br><span class="line">  			<span class="comment">//注意看这里</span></span><br><span class="line">        <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">        <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">        <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set thread ID */</span></span><br><span class="line">        <span class="keyword">this</span>.tid = nextThreadID();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这是一个线程的构造函数，也是证明了我们上面的说法，子线程被创建的时候会拷贝一份父线程的inheritableThreadLocal变量到自己的InheritableThreadLocal变量中。</p>
<h3 id="InheritableThreadLocal存在的问题"><a href="#InheritableThreadLocal存在的问题" class="headerlink" title="InheritableThreadLocal存在的问题"></a>InheritableThreadLocal存在的问题</h3><p>所以这样就结束了？不，且看下面一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> InheritableThreadLocal();</span><br><span class="line">        threadLocal.set(<span class="string">&quot;default value set by main thread&quot;</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        executorService.submit(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Pool-Thread:&quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; get 1:&quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//主线程修改一次</span></span><br><span class="line">        threadLocal.set(<span class="string">&quot;updated value set by main thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        executorService.submit(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Pool-Thread:&quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; get 2:&quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br></pre></td></tr></table></figure>

<p>日志输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pool-Thread:13 get 1:default value set by main thread</span><br><span class="line">Pool-Thread:13 get 2:default value set by main thread</span><br></pre></td></tr></table></figure>

<p>可以发现，如果是使用线程池，线程被复用，那么父线程就无法修改了。经过了上面对InheritableThreadLocal源码的分析，我们很容易找到原因：Thread的构造函数只会调用一次</p>
<p><strong>在线程池化的场景中，InheritableThreadLocal不再满足需求</strong></p>
<p>典型的使用场景</p>
<ul>
<li>分布式跟踪系统</li>
<li>日志收集记录系统上下文</li>
<li>Session级别的cache</li>
<li>应用容器或上层框架跨应用代码给下层<code>SDK</code>传递信息</li>
<li>…</li>
</ul>
<h3 id="TransmittableThreadLocal"><a href="#TransmittableThreadLocal" class="headerlink" title="TransmittableThreadLocal"></a>TransmittableThreadLocal</h3><p>这个是阿里开源的一种方案，它继承了InheritableThreadLocal，具体的资料可以参考  <a href="https://github.com/alibaba/transmittable-thread-local">Transmittable ThreadLocal(TTL)</a> 。</p>
<p>先看如何使用,首先是引用jar包，有多种方式，此处采用maven</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;transmittable-thread-local&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.11.4&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>然后是同样的逻辑代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TransmittableThreadLocal&lt;String&gt; context = <span class="keyword">new</span> TransmittableThreadLocal&lt;String&gt;();</span><br><span class="line">        context.set(<span class="string">&quot;value-set-in-parent&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 额外的处理，生成修饰了的对象executorService</span></span><br><span class="line">        executorService = TtlExecutors.getTtlExecutorService(executorService);</span><br><span class="line"></span><br><span class="line">        executorService.submit(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Pool-Thread:&quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; get 1:&quot;</span> + context.get());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        context.set(<span class="string">&quot;value-update-in-parent&quot;</span>);</span><br><span class="line"></span><br><span class="line">        executorService.submit(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Pool-Thread:&quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; get 2:&quot;</span> + context.get());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br></pre></td></tr></table></figure>

<p>程序输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pool-Thread:14 get 1:value-set-in-parent</span><br><span class="line">Pool-Thread:14 get 2:value-update-in-parent</span><br></pre></td></tr></table></figure>

<p>关于TransmittableThreadLocal原理是啥，还需要仔细阅读源码，这边暂时<code>打个欠条</code>，等我多梳理几遍再补上。可以参考 <a href="https://github.com/alibaba/transmittable-thread-local/blob/master/docs/developer-guide.md">开发者文档</a> 还有这个 <a href="https://github.com/alibaba/transmittable-thread-local/issues/123">应用场景和设计思考</a></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-RabbitMQ实践记录</title>
    <url>/2020/05/17/SpringBoot-RabbitMQ-practice/</url>
    <content><![CDATA[<h3 id="RabbitMQ-SpringBoot实践"><a href="#RabbitMQ-SpringBoot实践" class="headerlink" title="RabbitMQ + SpringBoot实践"></a>RabbitMQ + SpringBoot实践</h3><h4 id="为啥写这篇"><a href="#为啥写这篇" class="headerlink" title="为啥写这篇"></a>为啥写这篇</h4><p>接触并使用RabbitMQ已经有好几年了，每次配置MQ的时候，都要确保消息可靠不丢失、幂等性等问题。时间久了，曾经做过的最佳时间配置难免会忘记，甚至重复踩坑，这边目的就是整合一下靠谱的资源并做个笔记分享。</p>
<p>使用MQ时应该注意下面几个问题：</p>
<ul>
<li>消息丢失<ul>
<li>持久化</li>
<li>发送端发送失败：发送确认机制 confirm</li>
<li>消费端丢失：消费确认机制 ack</li>
</ul>
</li>
<li>重复消费、幂等性问题</li>
</ul>
<h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>关于RabbitMQ的相关基础概念、消息投递模式就不再重复了，可以参考此篇文章复习 <a href="https://github.com/suxiongwei/springboot-rabbitmq">RabbitMQ高可用</a></p>
<h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><h5 id="环境及依赖"><a href="#环境及依赖" class="headerlink" title="环境及依赖"></a>环境及依赖</h5><ul>
<li>SpringBoot  2.2.7.RELEASE</li>
<li>JDK 1.8</li>
<li>MySQL</li>
<li>RabbitMQ</li>
</ul>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><ol>
<li>生产者发送消息，并保存发送记录-发送提交</li>
<li>接收发送结果回调，更新发送记录-发送成功/失败</li>
<li>消费者接收到消息，查询消息记录是否存在，是否重复消费</li>
<li>执行具体业务逻辑，消费消息，更新消息记录为-已消费/消费异常  状态</li>
<li>根据消费结果执行手动 channel.basicAck</li>
</ol>
<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p><code>application.properties</code> 关键部分作用都有注释说明</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mq_practice?charset=utf8mb4&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Hikari连接池的设置</span></span><br><span class="line"><span class="comment">#最小连接</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.minimum-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="comment">#最大连接</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.maximum-pool-size</span>=<span class="string">15</span></span><br><span class="line"><span class="comment">#自动提交</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.auto-commit</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#最大空闲时常</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.idle-timeout</span>=<span class="string">30000</span></span><br><span class="line"><span class="comment">#连接池名</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.pool-name</span>=<span class="string">DatebookHikariCP</span></span><br><span class="line"><span class="comment">#最大生命周期</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.max-lifetime</span>=<span class="string">900000</span></span><br><span class="line"><span class="comment">#连接超时时间</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.connection-timeout</span>=<span class="string">15000</span></span><br><span class="line"><span class="comment">#心跳检测</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.connection-test-query</span>=<span class="string">SELECT 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## mybatis配置</span></span><br><span class="line"><span class="comment">#xml路径</span></span><br><span class="line"><span class="meta">mybatis-plus.mapper-locations</span>=<span class="string">classpath*:mapper/*.xml</span></span><br><span class="line"><span class="comment">#model路径</span></span><br><span class="line"><span class="meta">mybatis-plus.type-aliases-package</span>=<span class="string">com.microloan.entity</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rabbitmq config begin</span></span><br><span class="line"><span class="meta">spring.rabbitmq.addresses</span>=<span class="string">114.67.89.67:5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.rabbitmq.virtual-host</span>=<span class="string">/</span></span><br><span class="line"><span class="comment">#发送确认回调(exchange是否成功受理)</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated</span></span><br><span class="line"><span class="comment"># 发送失败退回（exchange到queue失败）</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-returns</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认机制：auto、manual、node，</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.acknowledge-mode</span>=<span class="string">manual</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.concurrency</span>=<span class="string">5</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.max-concurrency</span>=<span class="string">10</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.prefetch</span>=<span class="string">1</span></span><br><span class="line"><span class="comment">#间隔事件2（multiplier）倍递增，如1,2,4,8,16...但最大不超过max-attempts次</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.max-attempts</span>=<span class="string">8</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.retry.initial-interval</span>=<span class="string">2000</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.multiplier</span>=<span class="string">2</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.max-interval</span>=<span class="string">16000</span></span><br><span class="line"><span class="comment">#rabbitmq config end</span></span><br></pre></td></tr></table></figure>

<h5 id="RabbitMqConfig-java配置"><a href="#RabbitMqConfig-java配置" class="headerlink" title="RabbitMqConfig.java配置"></a>RabbitMqConfig.java配置</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMqConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST_QUEUE = <span class="string">&quot;approveRequestQueue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST_TOPIC_EXCHANGE = <span class="string">&quot;approveRequestExchange_topic&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST_ROUTING_KEY = <span class="string">&quot;approveRequestRouting&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.rabbitmq.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String addresses;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.rabbitmq.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.rabbitmq.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.rabbitmq.virtual-host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String virtualHost;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.rabbitmq.publisher-confirm-type&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String publisherConfirmType;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.rabbitmq.publisher-returns&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean publisherConfirmReturns;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">connectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">        connectionFactory.setAddresses(addresses);</span><br><span class="line">        connectionFactory.setUsername(username);</span><br><span class="line">        connectionFactory.setPassword(password);</span><br><span class="line">        connectionFactory.setVirtualHost(virtualHost);</span><br><span class="line">        <span class="comment">/** 如果要进行消息回调，则这里必须要设置*/</span></span><br><span class="line">        connectionFactory.setPublisherConfirmType(CachingConnectionFactory.ConfirmType.valueOf(publisherConfirmType.toUpperCase()));</span><br><span class="line">        connectionFactory.setPublisherReturns(publisherConfirmReturns);</span><br><span class="line">        <span class="keyword">return</span> connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//TODO 此处应改成非单例模式,下文有解释，先插眼</span></span><br><span class="line">    <span class="meta">@Bean(&quot;rabbitTemplateCallback&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplateCallBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RabbitTemplate template = <span class="keyword">new</span> RabbitTemplate(connectionFactory());</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">approveRequestQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(TEST_QUEUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicExchange <span class="title">approveRequestExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(TEST_TOPIC_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingApproveReqEx</span><span class="params">(Queue reqQueue, TopicExchange reqExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(reqQueue).to(reqExchange).with(TEST_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="消息保存"><a href="#消息保存" class="headerlink" title="消息保存"></a>消息保存</h5><p>为了防止消息重复消费，需要把消息入库。</p>
<p>创建一张表用来保存消息发送状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;mq_record&#96; (</span><br><span class="line">  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;msg_type&#96; varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,</span><br><span class="line">  &#96;msg_id&#96; varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,</span><br><span class="line">  &#96;status&#96; int(2) NOT NULL COMMENT &#39;1成功，0失败&#39;,</span><br><span class="line">  &#96;create_time&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  &#96;update_time&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;) USING BTREE,</span><br><span class="line">  KEY &#96;unique_index&#96; (&#96;msg_id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;9 DEFAULT CHARSET&#x3D;utf8mb4;</span><br></pre></td></tr></table></figure>

<h5 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h5><p>rabbitTemplate支持设置两个回调函数，<code>setConfirmCallback</code>和<code>setReturnCallback</code>。作用如下：</p>
<ul>
<li>setConfirmCallback 消息从生产者到达exchange触发，有个boolean类型的ack字段表示是否成功发送到路由exchange</li>
<li>setReturnCallback 消息成功发送到exchange，但分配给具体queue时失败会触发。</li>
</ul>
<p>要注意的一点是 rabbitTemplate一旦设置了这两个回调函数，是全局生效的，但是真正的项目里我们可能有多个生产者，而每个生产者发送消息后的回调处理逻辑可能是不一样的，所以我们<strong>应该在每个Producer中注入rabbitTemplate后才设置回调函数，而且rabbitTemplate应该是prototype类型（非单例）</strong></p>
<p>首先需要修改上面RabbitMqconfig类中的TODO处</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//支持回调的template</span></span><br><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span>  </span><br><span class="line"><span class="meta">@Bean(&quot;rabbitTemplateCallback&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplateCallBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RabbitTemplate template = <span class="keyword">new</span> RabbitTemplate(connectionFactory());</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后producer中的代码大概应该是这样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestProducer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource(name = &quot;rabbitTemplateCallback&quot;)</span> <span class="comment">//应该和RabbitMqConfig类中配置的名称一致</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRabbitTemplate</span><span class="params">(RabbitTemplate rabbitTemplate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.setConfirmCallback(...);</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.setReturnCallback(...);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="comment">//xxxx</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>光有回调不行啊，得找个地方记录每个消息的发送记录：消息id,发送时间，是否成功发送等信息。这里我们选择数据库 MySQL。完整的Producer如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MqRecordService mqRecordService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name = &quot;rabbitTemplateCallback&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRabbitTemplate</span><span class="params">(RabbitTemplate rabbitTemplate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">        <span class="comment">//消息从生产者到达exchange时返回ack，消息未到达exchange返回nack；</span></span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(ack)&#123;</span><br><span class="line">                    <span class="comment">//更新消息发送记录表的状态，采用乐观锁，</span></span><br><span class="line">                    mqRecordService.updateRecordStatus(correlationData.getId(),</span><br><span class="line">                            MqRecordStatusEnum.SEND.getCode(),MqRecordStatusEnum.SEND_SUCCESS.getCode());</span><br><span class="line">                    log.info(<span class="string">&quot;[MQ]消息发送结果确认 ack:&#123;&#125;,cause:&#123;&#125;,correlationData:&#123;&#125;&quot;</span>,ack,cause,correlationData);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    log.error(<span class="string">&quot;[MQ]消息发送失败，ack:&#123;&#125;,cause:&#123;&#125;,correlationData:&#123;&#125;&quot;</span>,ack,cause,correlationData);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消息进入exchange但未进入queue时会被调用。</span></span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.setReturnCallback(<span class="keyword">new</span> RabbitTemplate.ReturnCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">                log.error(<span class="string">&quot;[MQ]消息未成功进入queue:exchange:&#123;&#125;,route:&#123;&#125;,replyCode:&#123;&#125;,replyText:&#123;&#125;,message:&#123;&#125;&quot;</span>,exchange,routingKey,replyCode,replyText,message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> approveReqId  approveInfo自增id字段</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendRequest</span><span class="params">(<span class="keyword">long</span> approveReqId,String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            String key = UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">            MessageProperties mp = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">            mp.setMessageId(key);</span><br><span class="line">            Message msgObj = <span class="keyword">new</span> Message(msg.getBytes(),mp);</span><br><span class="line">            <span class="comment">//消息唯一键</span></span><br><span class="line">            CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//保存消息发送记录</span></span><br><span class="line">            MqRecord mqRecord = <span class="keyword">new</span> MqRecord();</span><br><span class="line">            mqRecord.setMsgType(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">            mqRecord.setMsgId(key);</span><br><span class="line">            mqRecord.setStatus(MqRecordStatusEnum.SEND.getCode());</span><br><span class="line">            mqRecord.setDataId(approveReqId);</span><br><span class="line">            <span class="keyword">this</span>.mqRecordService.businessSave(mqRecord);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Topic模式发送</span></span><br><span class="line">            <span class="keyword">this</span>.rabbitTemplate.convertAndSend(RabbitMqConfig.TEST_TOPIC_EXCHANGE,</span><br><span class="line">                    RabbitMqConfig.TEST_ROUTING_KEY,msgObj,correlationData);</span><br><span class="line">            log.info(<span class="string">&quot;[MQ]消息发送成功 &#123;&#125;,&#123;&#125;&quot;</span>,key,msg);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.error(<span class="string">&quot;[MQ]消息发送失败 &#123;&#125;,&#123;&#125;&quot;</span>,approveReqId,msg,e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h5><p>消费消息，成功之后手动调用ack。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MqRecordService mqRecordService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;RabbitMqConfig.TEST_QUEUE&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumeApproveRequest</span><span class="params">(Channel channel, Message msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String msgId = msg.getMessageProperties().getMessageId();</span><br><span class="line">        String msgBody = <span class="keyword">new</span> String(msg.getBody());</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            MqRecord mqRecord = <span class="keyword">this</span>.mqRecordService.queryByUniqueKey(msgId);</span><br><span class="line">            <span class="comment">//先检查是否已经消费过</span></span><br><span class="line">            <span class="keyword">if</span>(!checkRepetableMsg(mqRecord,msgBody))&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//msgBody消息内容，调用具体的业务逻辑</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">&quot;[MQ]消费消息成功:&#123;&#125;-&#123;&#125;&quot;</span>,msgId,msgBody);</span><br><span class="line">            <span class="keyword">this</span>.mqRecordService.updateRecordStatus(msgId, MqRecordStatusEnum.CONSUMED.getCode());</span><br><span class="line">            <span class="comment">//每个参数的作用</span></span><br><span class="line">            channel.basicAck(msg.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.error(<span class="string">&quot;[MQ]消费消息失败:&#123;&#125;-&#123;&#125;&quot;</span>,msgId,msgBody);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查重复检查的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mqRecord</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkRepetableMsg</span><span class="params">(MqRecord mqRecord,String msgBody)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mqRecord != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mqRecord.getStatus() == MqRecordStatusEnum.CONSUMED.getCode())&#123;</span><br><span class="line">                log.warn(<span class="string">&quot;重复的请求，忽略 &#123;&#125;&quot;</span>,mqRecord.getMsgId());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            log.warn(<span class="string">&quot;未知的申请 &#123;&#125;&quot;</span>,msgBody);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>文章只是记录了一下常用的代码，以及MQ使用中需要注意的细节。完整代码看<a href="https://github.com/eqshen/RabbitMQBestPractice">这里</a>。</p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>MQ</tag>
        <tag>RabbitMQ</tag>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot启动引导之自动注入</title>
    <url>/2020/06/27/SpringBoot%E5%90%AF%E5%8A%A8%E5%BC%95%E5%AF%BC%E4%B9%8B%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h3 id="SpringBoot版本"><a href="#SpringBoot版本" class="headerlink" title="SpringBoot版本"></a>SpringBoot版本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.2.5.RELEASE</span><br></pre></td></tr></table></figure>

<h3 id="启动注解"><a href="#启动注解" class="headerlink" title="启动注解"></a>启动注解</h3><h4 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h4><p>一个组合注解，相当于下面三个</p>
<ul>
<li>@SpringBootConfiguration （@Configuration）</li>
<li>@EnableAutoConfiguration</li>
<li>@ComponentScan 指定包的扫描路径</li>
</ul>
<h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>

<p>这个注解用于指定包的扫描路径。</p>
<ul>
<li>TypeExcludeFilter 作用是做<strong>扩展的组件过滤</strong></li>
<li>AutoConfigurationExcludeFilter 跟自动配置有关</li>
</ul>
<h4 id="Spring中Bean的装配方式"><a href="#Spring中Bean的装配方式" class="headerlink" title="Spring中Bean的装配方式"></a>Spring中Bean的装配方式</h4><ul>
<li>使用模式注解 <code>@Component</code> 等（Spring2.5+）</li>
<li>使用配置类 <code>@Configuration</code> 与 <code>@Bean</code> （Spring3.0+）</li>
<li>使用模块装配 <code>@EnableXXX</code> 与 <code>@Import</code> （Spring3.1+）</li>
</ul>
<h5 id="Import的四种装配方式"><a href="#Import的四种装配方式" class="headerlink" title="@Import的四种装配方式"></a>@Import的四种装配方式</h5><p>EnableXXX注解主要与@Import配合使用。</p>
<p>假设我们要把Red,Yellow,Blue,Green这几个类分别用 普通类、@Configuration，ImportSelector，ImportBeanDefinitionRegistrar这四种方式注入到Spring的容器中。</p>
<ul>
<li>首先我们定义四个颜色类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I am red&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yellow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I am yellow&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I am blue&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Green</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I am Green&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="第一种：普通类"><a href="#第一种：普通类" class="headerlink" title="第一种：普通类"></a>第一种：普通类</h6><p>首先定义一个注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Import(&#123;Red.class&#125;)</span> <span class="comment">//注意此处</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableColor &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义一个配置类，这个类作用就是使用EnableColor注解，也可以直接把EnableColor添加在SpringBoot的启动类上，但是这样会导致注入很多不在我们目前观察范围内的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableColor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorRegistrarConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义一个测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(ColorRegistrarConfiguration.class);</span><br><span class="line">        String[] beanDefinitionNames =  ctx.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;=======&gt; &quot;</span>+beanDefinitionName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">=======&gt; org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">=======&gt; org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">=======&gt; org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">=======&gt; org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">=======&gt; org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">=======&gt; colorRegistrarConfiguration</span><br><span class="line">=======&gt; com.eqshen.springprobe.bean.Red</span><br></pre></td></tr></table></figure>



<h6 id="第二种：Configuration方式"><a href="#第二种：Configuration方式" class="headerlink" title="第二种：Configuration方式"></a>第二种：Configuration方式</h6><p>使用configuration方式定义注入Yellow类实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Yellow <span class="title">yellow</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Yellow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改EnableColor注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Import(&#123;Red.class,ColorConfig.class&#125;)</span> <span class="comment">//注意此处</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableColor &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次执行上面的<code>MainApp#main</code>方法，输出内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">=======&gt; org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">=======&gt; org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">=======&gt; org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">=======&gt; org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">=======&gt; org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">=======&gt; colorRegistrarConfiguration</span><br><span class="line">=======&gt; com.eqshen.springprobe.bean.Red</span><br><span class="line">=======&gt; com.eqshen.springprobe.config.ColorConfig</span><br><span class="line">=======&gt; yellow</span><br></pre></td></tr></table></figure>



<h6 id="第三种：-ImportSelector方式"><a href="#第三种：-ImportSelector方式" class="headerlink" title="第三种： ImportSelector方式"></a>第三种： ImportSelector方式</h6><p>定义<code>ColorImportSelector</code>类，继承自 <code>ImportSelector</code>，ImportSelector接口只定义了一个<code>selectImports()</code>，用于指定需要注册为bean的Class名称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;Blue.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改EnableColor注解上的Import注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;Red.class,ColorConfig.class,ColorImportSelector.class&#125;)</span></span><br></pre></td></tr></table></figure>

<p>再次执行MainApp#main方法，得到输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">=======&gt; org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">=======&gt; org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">=======&gt; org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">=======&gt; org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">=======&gt; org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">=======&gt; colorRegistrarConfiguration</span><br><span class="line">=======&gt; com.eqshen.springprobe.bean.Red</span><br><span class="line">=======&gt; com.eqshen.springprobe.config.ColorConfig</span><br><span class="line">=======&gt; yellow</span><br><span class="line">=======&gt; com.eqshen.springprobe.bean.Blue</span><br></pre></td></tr></table></figure>



<h6 id="第四种-ImportBeanDefinitionRegistrar方式"><a href="#第四种-ImportBeanDefinitionRegistrar方式" class="headerlink" title="第四种 ImportBeanDefinitionRegistrar方式"></a>第四种 ImportBeanDefinitionRegistrar方式</h6><p>定义一个类<code>ColorImportBeanDefinitionRegistrar</code>并继承 <code>ImportBeanDefinitionRegistrar</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//指定注册bean名称</span></span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;green&quot;</span>, <span class="keyword">new</span> RootBeanDefinition(Green.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改EnableColor注解上的Import注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;Red.class,ColorConfig.class,ColorImportSelector.class,ColorImportBeanDefinitionRegistrar.class&#125;)</span></span><br></pre></td></tr></table></figure>

<p>再次执行MainApp#main方法，得到输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">=======&gt; org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">=======&gt; org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">=======&gt; org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">=======&gt; org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">=======&gt; org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">=======&gt; colorRegistrarConfiguration</span><br><span class="line">=======&gt; com.eqshen.springprobe.bean.Red</span><br><span class="line">=======&gt; com.eqshen.springprobe.config.ColorConfig</span><br><span class="line">=======&gt; yellow</span><br><span class="line">=======&gt; com.eqshen.springprobe.bean.Blue</span><br><span class="line">=======&gt; green</span><br></pre></td></tr></table></figure>

<h6 id="四种方式区别及应用场景"><a href="#四种方式区别及应用场景" class="headerlink" title="四种方式区别及应用场景"></a>四种方式区别及应用场景</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;</span></span><br><span class="line"><span class="meta">  Red.class,</span></span><br><span class="line"><span class="meta">  ColorConfig.class,</span></span><br><span class="line"><span class="meta">  ColorImportSelector.class,</span></span><br><span class="line"><span class="meta">  ColorImportBeanDefinitionRegistrar.class&#125;)</span></span><br></pre></td></tr></table></figure>

<p>待定（稍后补充）</p>
<h4 id="SpringBoot的自动装配"><a href="#SpringBoot的自动装配" class="headerlink" title="SpringBoot的自动装配"></a>SpringBoot的自动装配</h4><p>SpringBoot的自动配置完全由 <code>@EnableAutoConfiguration</code> 开启。<code>@EnableAutoConfiguration</code>是<code>SpringBootApplication</code>上的注解，其内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h5><p>自动扫描将从标注此注解的类所在的包开始，其内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;Registrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那这个<code>Registrar.class</code>作用是啥呢？它是<code>AutoConfigurationPackages.java</code>的一个静态内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125; to store the base package from the importing</span></span><br><span class="line"><span class="comment">	 * configuration.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">			register(registry, <span class="keyword">new</span> PackageImport(metadata).getPackageName());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> PackageImport(metadata));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>从注释说明来看，这个Registrar的功能主要就是用来保存 base package的name以便后续使用。<code>AnnotationMetadata metadata</code>就是根目录的元数据信息，这里暂时不深入。</p>
<p>basePackage的作用：除了Spring自己使用，也可以提供给三方插件，如Mybatis等。</p>
<h5 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import(AutoConfigurationImportSelector.class)"></a>@Import(AutoConfigurationImportSelector.class)</h5><p>ImportSelector我们之前有提到过，如<code>ColorImportSelector</code>，看一下<code>AutoConfigurationImportSelector.class</code>关键源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">			<span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">		&#125;</span><br><span class="line">		AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">				.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">		AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,</span><br><span class="line">				annotationMetadata);</span><br><span class="line">		<span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>函数的作用是根据输入<code>annotationMetadata</code>，输出需要被import的类名数组。其中，<code>loadMetadata</code>方法是把<code>META-INF/spring.factories</code>配置文件中的内容加载封装成 AutoConfigurationMetadata。</p>
<p>spring.factories中配置如下（格式）：keyName=a,b,c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Auto Configuration Import Filters</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter&#x3D;\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnBeanCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnClassCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition</span><br><span class="line"></span><br><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br></pre></td></tr></table></figure>

<p>从上面的 Properties 中发现，所有配置的 EnableAutoConfiguration 的自动配置类，都<strong>以 AutoConfiguration 结尾</strong>！由此规律，以后我们要了解一个 SpringBoot 的模块或者第三方集成的模块时，就可以<strong>大胆猜测基本上一定会有 XXXAutoConfiguration 类出现</strong>！</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>实现自己的SpringBoot Starter</title>
    <url>/2020/09/05/create-your-starter/</url>
    <content><![CDATA[<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>前两个月因为工作变动，水博客的节奏有点慢，平时为了熟悉公司业务，加上新公司加班较多，落下了….现在继续开始水</p>
<h3 id="要做啥？"><a href="#要做啥？" class="headerlink" title="要做啥？"></a>要做啥？</h3><p>之前有了解过SpringBoot启动流程，其中一块就涉及到SpringBoot Starter的内容，现在公司封装的东西基本上都是配合SpringBoot快速使用的，比如引入一个依赖，然后加个@EnableXXXX注解，就可以了。。。今天要实现一个自己的SpringBoot starter,用来实现打印方法的执行时间，惭愧的想到了之前自己的实现方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String getUserInfo()&#123;</span><br><span class="line">        long startTs &#x3D; System.currentTimeMillis();</span><br><span class="line">        &#x2F;&#x2F;业务逻辑</span><br><span class="line"></span><br><span class="line">        long endTs &#x3D; System.currentTimeMillis();</span><br><span class="line">        &#x2F;&#x2F;输出时间</span><br><span class="line">        log.info(&quot;getUserInfo 用时：&#123;&#125; ms&quot;,endTs - startTs);</span><br><span class="line">        return &quot;xxx&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这无疑是愚蠢的，记得有一次，领导找到我：‘xxx,你拉一下日志，类似于上面这种有计算执行用时的所有当天日志，然后计算一下每个方法的平均耗时，95线等，’，我：？？？<br>当场就懵逼了，因为每个方法里打印的日志格式都不统一，统计起来就很费力了，如：</p>
<ul>
<li><code>log .info(&quot;xxx 耗时：&#123;&#125; ms&quot;,endTs - startTs);</code></li>
<li><code>log .info(&quot;xxx 用时：&#123;&#125; 毫秒&quot;,endTs - startTs);</code></li>
<li><code>log .info(&quot;xxx 用时 &#123;&#125; 秒&quot;,（endTs - startTs)/1000);</code></li>
</ul>
<h3 id="怎么做更好？"><a href="#怎么做更好？" class="headerlink" title="怎么做更好？"></a>怎么做更好？</h3><ul>
<li>当然，我第一时间是想到了 封装一个Util，在所有需要打印时间的地方，都调用它，这样，输出的格式就可以统一了。但是，代码还是侵入了业务代码，某天想停用，就很不方便。</li>
<li>另一种比较好的做法就是利用aop了，今天就试试手。当然还有更好的，如点评开源的Cat之类的，更专业。</li>
</ul>
<h3 id="动手实践"><a href="#动手实践" class="headerlink" title="动手实践"></a>动手实践</h3><ul>
<li>开始之前要对SpringBoot的启动流程有简单的了解，特别是ImportSelector这些</li>
<li>除此之外，AOP相关知识也必不可少，如@Aspect使用等。</li>
</ul>
<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ul>
<li>通过AOP实现无侵入的打印特定格式日志的功能</li>
<li>可以封装成模块，方便复用</li>
<li>在某方法上添加指定注解即可打印该方法的执行时间</li>
<li>模块进入之后通过总开关控制：@EnableXXXX</li>
</ul>
<h4 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h4><p>这里仅给出了关键部分的依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-autoconfigure&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.7.30&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="定义在方法上使用的注解"><a href="#定义在方法上使用的注解" class="headerlink" title="定义在方法上使用的注解"></a>定义在方法上使用的注解</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface LogUsedTime &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 自定义输出的方法名字,不指定则取方法名</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    String aliasMethodName() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 日志级别</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    LogLevel logLevel() default LogLevel.INFO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="定义aop切面处理类"><a href="#定义aop切面处理类" class="headerlink" title="定义aop切面处理类"></a>定义aop切面处理类</h4><p>指定切点以及切面逻辑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@EnableAspectJAutoProxy(exposeProxy &#x3D; true,proxyTargetClass &#x3D; true)</span><br><span class="line">public class LogUsedTimeAspect implements PriorityOrdered &#123;</span><br><span class="line"></span><br><span class="line">    private Logger log &#x3D; LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义切点</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Pointcut(&quot;@annotation(com.eqshen.anno.LogUsedTime)&quot;)</span><br><span class="line">    private void logUsedTimeAnnotationCut()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;使用上面定义的切点</span><br><span class="line">    @Around(value &#x3D; &quot;logUsedTimeAnnotationCut() &amp;&amp; @annotation(logUsedTime)&quot;)</span><br><span class="line">    public Object methodExecute(ProceedingJoinPoint point, LogUsedTime logUsedTime) throws Throwable &#123;</span><br><span class="line">        String aliasMethodName &#x3D; logUsedTime.aliasMethodName();</span><br><span class="line">        LogLevel logLevel &#x3D; logUsedTime.logLevel();</span><br><span class="line"></span><br><span class="line">        String methodName &#x3D; point.getSignature().getName();</span><br><span class="line">        if(!StringUtils.isEmpty(aliasMethodName))&#123;</span><br><span class="line">            methodName &#x3D; aliasMethodName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long startTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line">        Object result &#x3D; point.proceed();</span><br><span class="line">        long endTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;log</span><br><span class="line">        doLog(logLevel,methodName,endTimestamp - startTimestamp);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void doLog(LogLevel logLevel,String methodName,long usedTimeMs)&#123;</span><br><span class="line">        String format &#x3D; String.format(&quot;[Time Use] Task %s used time: %d ms&quot;, methodName,usedTimeMs);</span><br><span class="line"></span><br><span class="line">        switch (logLevel)&#123;</span><br><span class="line">            case OFF:</span><br><span class="line">                &#x2F;&#x2F;do nothing</span><br><span class="line">                break;</span><br><span class="line">            case WARN:</span><br><span class="line">                log.warn(format);</span><br><span class="line">                break;</span><br><span class="line">            case DEBUG:</span><br><span class="line">                log.debug(format);</span><br><span class="line">                break;</span><br><span class="line">            case ERROR:</span><br><span class="line">                log.error(format);</span><br><span class="line">                break;</span><br><span class="line">            case FATAL:</span><br><span class="line">                log.error(format);</span><br><span class="line">                break;</span><br><span class="line">            case TRACE:</span><br><span class="line">                log.trace(format);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                log.info(format);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * aop优先级放置在最后</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="定义自动引入Selector"><a href="#定义自动引入Selector" class="headerlink" title="定义自动引入Selector"></a>定义自动引入Selector</h4><p>自定义Selector，在SpringBoot启动阶段可以自动装载我们上面定义的aop切面处理类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EnableEQTimeLogSelector implements ImportSelector &#123;</span><br><span class="line"></span><br><span class="line">    private Logger log &#x3D; LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        log.info(&quot;(*^▽^*) EQTimeLog组件启用...OK&quot;);</span><br><span class="line">        return new String[]&#123;LogUsedTimeAspect.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="定义总开关-EnableXXX"><a href="#定义总开关-EnableXXX" class="headerlink" title="定义总开关 @EnableXXX"></a>定义总开关 @EnableXXX</h4><p>自定义开关注解，挂载Selector，让一切变得简单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 开关</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Import(EnableEQTimeLogSelector.class)</span><br><span class="line">public @interface EnableEQTimeLog &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用-amp-测试"><a href="#使用-amp-测试" class="headerlink" title="使用 &amp; 测试"></a>使用 &amp; 测试</h4><p>首先，创建一个新的SpringBoot项目，依赖我们 上面的项目。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.eqshen&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;time-log-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p>创建测试类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class TestService &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;使用注解，输出方法执行耗时</span><br><span class="line">    @LogUsedTime(aliasMethodName &#x3D; &quot;打招呼&quot;)</span><br><span class="line">    public String sayHello(String name)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;hello &quot;+ name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写Junit单元测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">&#x2F;&#x2F;注意这里，开启功能</span><br><span class="line">@EnableEQTimeLog</span><br><span class="line">class EqlogDemoApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private TestService testService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        testService.sayHello(&quot;tom&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下日志输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">2020-09-09 23:56:48.572  INFO 10589 --- [           main] com.demo.EqlogDemoApplicationTests       : No active profile set, falling back to default profiles: default</span><br><span class="line">2020-09-09 23:56:48.655  INFO 10589 --- [           main] c.e.selector.EnableEQTimeLogSelector     : (*^▽^*) EQTimeLog组件启用...OK</span><br><span class="line">2020-09-09 23:56:49.201  INFO 10589 --- [           main] com.demo.EqlogDemoApplicationTests       : Started EqlogDemoApplicationTests in 15.8 seconds (JVM running for 16.704)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">2020-09-09 23:56:50.342  INFO 10589 --- [           main] com.eqshen.aspect.LogUsedTimeAspect      : [Time Use] Task 打招呼 used time: 1015 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>至此，整篇文章水完了。没有任何难度的demo，仅仅是熟悉如何自定义starter，以及之前学习过@Import这些知识的简单实践。<br>虽然很简单，但是在实操的时候还是可能会遇到意想不到的问题，如 maven无法引用本地仓库的jar（版本原因等）。共勉。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>再谈事务</title>
    <url>/2020/10/02/%E5%86%8D%E8%B0%88%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="再谈事务"><a href="#再谈事务" class="headerlink" title="再谈事务"></a>再谈事务</h2><p>最近在复习事务相关的知识，结合实际工作中的方案，加深对事务的理解</p>
<h3 id="一、基础概念回顾"><a href="#一、基础概念回顾" class="headerlink" title="一、基础概念回顾"></a>一、基础概念回顾</h3><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><ul>
<li><p>Atomicity（原子性）：多个写操作，要全部成功，要么全部失败/回滚 </p>
</li>
<li><p>Consistency（一致性）：</p>
<ul>
<li><p>事务可以保障数据库从一个状态转移到另一个状态，没有中间状态。（如A向B转账）</p>
</li>
<li><p>中间状态不可以被观察到。</p>
<blockquote>
<p>针对“中间状态”说下个人理解，在强一致性的事务中，肯定是要求无法被观察到的；但是在弱一致性的柔性事务中，中间状态是可以被观察到的，只要满足最终一致性即可。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Isolation（隔离性）：两个并发的事务在执行时，互不影响。事务1对某个数值的修改不能影响到事务2，事务2也不知道事务1干了啥，完全是两个黑盒操作。当如果两个事务同时对某一资源进行访问时，就要进行加锁控制，并行变串行，但依然满足“并发”的概念。</p>
</li>
<li><p>Durablity（持久性）：事务成功提交后，更改永久保存，不能回滚。</p>
</li>
</ul>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>发生脏读</th>
<th>不可重复读</th>
<th>发生幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read Uncommitted 读未提交</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>Read Committed 读已提交（不可重复读）</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>Repeatable Read 可重复读</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>Serializable 串行化</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<ul>
<li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li>
<li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。关注点是已存在数据的修改。</li>
<li>幻读：跟RC容易混，举例：事务A读取某班级所有学生数据共32人，然后事务B插入了2名新学生数据到该班级，事务A再次读取所有学生数据，发现有34人。事务A:”怎么变成34了难道刚才我发生幻觉了？”….这就是幻读，关注点在行数的增加。<blockquote>
<p>如果是减少2人，还是幻读吗？答案：不是了。<code>幻读</code>强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。所以<code>减少两人</code>这种情况应该算是 <strong>不可重复读</strong>。</p>
</blockquote>
</li>
</ul>
<h3 id="二、分布式事务"><a href="#二、分布式事务" class="headerlink" title="二、分布式事务"></a>二、分布式事务</h3><h5 id="1-何为分布式事务"><a href="#1-何为分布式事务" class="headerlink" title="1.何为分布式事务"></a>1.何为分布式事务</h5><p>相对于本地事务而言，在SOA等架构下，用户一次操作，需要修改<strong>多个数据库</strong>的数据且要求该次操作要满足事务特性（ACID）, 而跨越了多个数据库实例的情况下，单机事务就不适用了。</p>
<p><strong>举个栗子</strong>：用户的资产余额数据保存在 订单库A，而用户的积分保存在 活动库B，库存数据保存在 商品库C。按照业务要求，用户完成一笔下单，要赠送订单金额*100的活动积分。那么用户单次的下单行为就至少存在以下数据库修改：</p>
<ul>
<li>订单库A 金额减少 x元</li>
<li>订单库B 用户积分增加 x*100点</li>
<li>商品库C 要进行扣库存操作</li>
</ul>
<p>以上 就是典型需要使用分布式事务的场景了。</p>
<h5 id="2-分布式理论"><a href="#2-分布式理论" class="headerlink" title="2. 分布式理论"></a>2. 分布式理论</h5><p>比较常见的主要是<strong>CAP理论</strong>和<strong>BASE理论</strong>，这里不做介绍可以自行百度复习。</p>
<h3 id="三、常见的分布式方案-XA与TCC"><a href="#三、常见的分布式方案-XA与TCC" class="headerlink" title="三、常见的分布式方案(XA与TCC)"></a>三、常见的分布式方案(XA与TCC)</h3><h4 id="1-DTP模型-二阶段提交（2PC）"><a href="#1-DTP模型-二阶段提交（2PC）" class="headerlink" title="1.DTP模型-二阶段提交（2PC）"></a>1.DTP模型-二阶段提交（2PC）</h4><blockquote>
<p>Distributed Transaction Processing（DTP）采用的是XA协议</p>
</blockquote>
<p>模型中涉及到的角色</p>
<ul>
<li>TM,Transaction Manager 事务管理器（也称协调者）</li>
<li>RM, Resource Manager 资源管理器（也称参与者）</li>
<li>AP,Application 应用，通常和RM看做一个整体</li>
</ul>
<h5 id="第一阶段-投票阶段"><a href="#第一阶段-投票阶段" class="headerlink" title="第一阶段 投票阶段"></a>第一阶段 投票阶段</h5><p>目的：TM询问各个数据库实例参与者RM 是否具备正常执行事务的条件。</p>
<p>主要步骤</p>
<ol>
<li>协调者向所有的参与者发送事务执行请求，并等待参与者反馈事务执行结果</li>
<li>事务参与者收到请求之后，执行事务，<strong>但不提交</strong>，并记录事务日志。</li>
<li>参与者将自己事务执行情况反馈给协调者，同时<strong>阻塞等待</strong>协调者的后续指令。</li>
</ol>
<h5 id="第二阶段-事务提交阶段"><a href="#第二阶段-事务提交阶段" class="headerlink" title="第二阶段 事务提交阶段"></a>第二阶段 事务提交阶段</h5><p>第一阶段的询问将会出现三种情况</p>
<ol>
<li>所有参与者都返回成功</li>
<li>部分参与者成功，部分返回失败</li>
<li>协调者等待超时</li>
</ol>
<h6 id="对于第1种情况，协调者会通知所有参与者提交事务"><a href="#对于第1种情况，协调者会通知所有参与者提交事务" class="headerlink" title="对于第1种情况，协调者会通知所有参与者提交事务"></a>对于第1种情况，协调者会通知所有参与者提交事务</h6><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjbb6cuxwwj30m20gnwfg.jpg" style="zoom:50%;" />

<h6 id="对于第2，3种情况，协调者就会发送回滚通知"><a href="#对于第2，3种情况，协调者就会发送回滚通知" class="headerlink" title="对于第2，3种情况，协调者就会发送回滚通知"></a>对于第2，3种情况，协调者就会发送回滚通知</h6><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjbb8fo47gj30m20gnjsc.jpg" style="zoom:50%;" />

<h5 id="两阶段方案的不足之处"><a href="#两阶段方案的不足之处" class="headerlink" title="两阶段方案的不足之处"></a>两阶段方案的不足之处</h5><ol>
<li>协调者的单点问题，协调者挂了，参与者会无限等待（可引入超时机制解决）；</li>
<li>同步阻塞，所有参与者都同步阻塞等待协调者“指挥”下一步操作，效率太低；</li>
<li>数据不一致，两阶段协议的整个流程中，还是存在导致数据不一致的可能（部分参与者提交失败，协调者与参与者同时挂了）</li>
</ol>
<h4 id="2-DTP模型-三阶段提交（3PC）"><a href="#2-DTP模型-三阶段提交（3PC）" class="headerlink" title="2.DTP模型-三阶段提交（3PC）"></a>2.DTP模型-三阶段提交（3PC）</h4><p>是三阶段协议王者归来吗？且往下看</p>
<p>三阶段主要比二阶段增加了一个“预询”阶段，以及超时策略来减少集群的阻塞时间。</p>
<h5 id="第一阶段-Can-Commit"><a href="#第一阶段-Can-Commit" class="headerlink" title="第一阶段 Can_Commit"></a>第一阶段 Can_Commit</h5><ol>
<li>协调者向所有参与者发送事务询问通知，询问是否可以执行事务，并等待响应</li>
<li>各个参与者依据自身状态给出 预估值答复，如果可以执行事务，就进入预备状态</li>
</ol>
<h5 id="第二阶段-Pre-Commit"><a href="#第二阶段-Pre-Commit" class="headerlink" title="第二阶段 Pre_Commit"></a>第二阶段 Pre_Commit</h5><p>第一阶段的“预询”结果也会有三种</p>
<ol>
<li>所有参与者都返回确定信息</li>
<li>部分参与者回复 否定信息</li>
<li>协调者等待超时</li>
</ol>
<p>对于第1种情况，协调者会向所有参与者发送执行事务请求（和两阶段协议的第一阶段内容一样）：</p>
<ol>
<li>协调者向所有的事务参与者发送事务执行通知</li>
<li>参与者收到通知后，执行事务，<strong>但不提交</strong></li>
<li>参与者将事务执行情况返回给客户端</li>
</ol>
<p>对于第2、3种情况，协调者会发送abort通知，所有参与者退出“预备”状态</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjbbadcbe0j30mc0gn754.jpg" style="zoom:50%;" />

<h5 id="第三阶段-Do-Commit"><a href="#第三阶段-Do-Commit" class="headerlink" title="第三阶段 Do_Commit"></a>第三阶段 Do_Commit</h5><p>第二阶段的执行结果也会有 三种情况：</p>
<ol>
<li>所有参与参与者执行事务成功</li>
<li>部分参与者执行事务失败</li>
<li>协调者等待超时</li>
</ol>
<p>同样的，协调者会针对上述3种情况进行不同的处理</p>
<h6 id="对于第1种，协调者会向所有参与者发送事务提交请求"><a href="#对于第1种，协调者会向所有参与者发送事务提交请求" class="headerlink" title="对于第1种，协调者会向所有参与者发送事务提交请求"></a>对于第1种，协调者会向所有参与者发送事务提交请求</h6><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjbbbah8o8j30k20qagmz.jpg" style="zoom:50%;" />

<h6 id="对于第2，3种，协调者会发送事务回滚通知给所有参与者。"><a href="#对于第2，3种，协调者会发送事务回滚通知给所有参与者。" class="headerlink" title="对于第2，3种，协调者会发送事务回滚通知给所有参与者。"></a>对于第2，3种，协调者会发送事务回滚通知给所有参与者。</h6><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjbbca965kj30ks0qaq4b.jpg" style="zoom:50%;" />

<blockquote>
<p>补充，如果在该阶段，参与者等待协调者发送的消息超时，那么默认会提交事务。而如果此时协调者发送的是回滚通知，那么还是会出现数据不一致的可能，也就是说，三阶段相比两阶段主要提交了两点：1.第一阶段的预询操作更加轻量级，如果有部分参与者无法执行事务，直接Abort，而不用所有参与者预执行事务；2.增加了超时自动提交机制，避免了长时间等待造成资源浪费。</p>
</blockquote>
<blockquote>
<p>思考：如果第三阶段，最后有参与者返回“提交事务失败”，该怎么处理？</p>
</blockquote>
<h4 id="2PC和3PC的区别"><a href="#2PC和3PC的区别" class="headerlink" title="2PC和3PC的区别"></a>2PC和3PC的区别</h4><ul>
<li>2PC 只有协调者超时机制，3PC协调者参与者都有超时机制</li>
<li>3PC 将2PC的第一阶段拆为2步，粒度更细，资源锁定时间更短</li>
</ul>
<h4 id="3-TCC方案"><a href="#3-TCC方案" class="headerlink" title="3.TCC方案"></a>3.TCC方案</h4><p>TCC是try,confirm/cancel的简称，即TCC主要有两阶段组成，分别是Try阶段和Confirm/Cancel阶段。</p>
<blockquote>
<p>通俗点讲，一个完整的事务 = Try + Confirm或Cancel</p>
</blockquote>
<p>TCC方案是一种柔性事务方案的实现，那么何为<code>柔性事务</code>？</p>
<h5 id="一阶段-Try"><a href="#一阶段-Try" class="headerlink" title="一阶段-Try"></a>一阶段-Try</h5><p>Try中的逻辑与传统事务机制中的业务逻辑相同。该阶段主要的工作是：完成所有业务检查，预留必须的业务资源。</p>
<h5 id="二阶段-Confirm"><a href="#二阶段-Confirm" class="headerlink" title="二阶段-Confirm"></a>二阶段-Confirm</h5><p>真正执行的业务逻辑，不做任何业务检查，<strong>但只能使用Try阶段预留的资源</strong>。此外，confirm操作还有几点要求</p>
<ol>
<li>Try操作成功，Confirm操作一定会成功，不存在失败的情况；</li>
<li>Confirm操作要满足幂等性，保证一笔分布式事务能且只能成功一次。</li>
</ol>
<h5 id="二阶段-Cancel"><a href="#二阶段-Cancel" class="headerlink" title="二阶段-Cancel"></a>二阶段-Cancel</h5><p>释放 Try 阶段预留的业务资源。同样的，Cancel 操作也需要满足幂等性。</p>
<h5 id="TCC方案存在的三个问题"><a href="#TCC方案存在的三个问题" class="headerlink" title="TCC方案存在的三个问题"></a>TCC方案存在的三个问题</h5><ol>
<li>空回滚 - 没有调用 try，直接调用Cancel，要求在设计系统时，能够是被空回滚请求，并处理。</li>
<li>幂等 - 由于网络原因Contirm、Cancel接口被多次调用，要保证重复执行与只执行一次具有同样效果，可以设置当时事务状态来避免</li>
<li>悬挂 - Cancel比Try先执行了。什么情况下会发生：网络原因Try操作阻塞，超时后，TCC框架协调器调用Cancel接口，Cancel执行后，Try操作才到达。解决方案：执行try操作之前先查询一下二阶段接口是否被执行</li>
</ol>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ol>
<li>TCC相对于 XA 等传统模型，其特征在于它不依赖 RM 对分布式事务的支持，而是通过对业务逻辑的分解来实现分布式事务。</li>
<li>TCC要根据自身业务模型特点来控制并发。</li>
</ol>
<h3 id="XA与TCC的异同"><a href="#XA与TCC的异同" class="headerlink" title="XA与TCC的异同"></a>XA与TCC的异同</h3><h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h5><ul>
<li><p>XA对隔离性的控制，是通过对依赖的资源进行加锁的方式，且要求对锁的持有要到最后一阶段，这种长时间对资源进行加锁的方式，会使得并发性能非常低下</p>
</li>
<li><p>TCC对隔离性的处理思想是通过业务层来控制，Try阶段结束后就释放底层数据库锁，由业务层对持有的资源进行加锁，从而降低锁的粒度，提高并发性。</p>
<blockquote>
<p>上面这是什么意思呢？举个例子，A账户有100元，A向B账户转账30元，在try阶段会对A账户扣除30元，并增加30元冻结资金（这依赖底层数据库锁保证原子性），这样就在业务层面把30块给锁定了（转为业务层加锁），然后Confirm阶段向B账户增加30元，如果增加成功，则将A账户冻结资金扣除；如果失败则执行Cancel，将30元冻结资金返回给A账户。这样即使A账户需要同时给多个账户转账30元，也不是出现”双花“的情况。</p>
</blockquote>
</li>
</ul>
<h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><ul>
<li>XA通过两阶段提交协议来控制原子性，即Prepare, Commit/Rollback</li>
<li>TCC也是通过两阶段来控制原子性，只不过更像是应用层的原子性，Try相当于 Prepare，Confirm相当于Commit，Cancel相当于Rollback。</li>
</ul>
<h5 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h5><ul>
<li>XA于TCC的一致性都是由其原子性和隔离性来保证</li>
<li>XA方案的一致性是强一致性，数据的中间过程状态是无法被观察到的；而TCC的中间状态是可以被观察到的，是一种弱一致性（追求最终一致性）。</li>
</ul>
<h3 id="四、常见的开源解决方案"><a href="#四、常见的开源解决方案" class="headerlink" title="四、常见的开源解决方案"></a>四、常见的开源解决方案</h3><ol>
<li><p><a href="http://seata.io/zh-cn/docs/overview/what-is-seata.html">Seata</a></p>
</li>
<li><p><a href="https://github.com/changmingxie/tcc-transaction">Tcc-Transaction</a></p>
</li>
<li><p><a href="https://github.com/liuyangming/ByteTCC">ByteTCC</a></p>
</li>
</ol>
<h3 id="五、最后"><a href="#五、最后" class="headerlink" title="五、最后"></a>五、最后</h3><p>以上内容只是整理作为学习笔记，仅抛砖引玉作用，大家共同学习进步，你学废了嘛？</p>
<h3 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h3><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzUzMzU5Mjc1Nw==&amp;mid=2247483681&amp;idx=1&amp;sn=05845495c5ef33683addd98fffc72106&amp;chksm=faa0eefbcdd767edbf46cea6f223b426e276dd4d9b19cce64f59387590818f5e4eb96c7d2533&amp;mpshare=1&amp;scene=2&amp;srcid=0118GSYShGZaOyCndUoAqsae&amp;from=timeline#rd">分布式事务综述</a></li>
<li><a href="https://blog.csdn.net/pyycsd/article/details/102803015">分布式事务-两阶段与三阶段提</a></li>
<li><a href="https://www.bytesoft.org/tcc-intro/">TCC事务机制简介</a></li>
<li><a href="https://www.zhihu.com/question/48627764">如何理解TCC分布式事务</a></li>
<li><a href="https://juejin.im/post/6844903829603876878">分布式事务 Seata TCC 模式深度解析</a></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>事务</category>
      </categories>
      <tags>
        <tag>事务</tag>
        <tag>Transaction</tag>
      </tags>
  </entry>
  <entry>
    <title>ShardingSphere分库分表体验</title>
    <url>/2020/11/02/ShardingSphere%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h3 id="ShardingSphere分库分表实践"><a href="#ShardingSphere分库分表实践" class="headerlink" title="ShardingSphere分库分表实践"></a>ShardingSphere分库分表实践</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>当系统中数据库成功性能的瓶颈，特别是一张表中的数据量过大，达到500w甚至1000w时，这种情况下，通过建立有效索引也难以满足查询的效率要求时，就需要考虑到分库分表，分表一般是将表进行水平拆分，如根据用户id，订单编号等策略。</p>
<p>举个栗子：将订单表t_order拆分成四张表，分别是t_order_0,t_order_1,t_order_2,t_order_3；分表的路由策略为 <code>order_no % 4</code>；</p>
<p>这种情况下：</p>
<ul>
<li>订单号为10000的订单 将被保存在 10000%4 = 0 即 t_order_0表；</li>
<li>订单号为 10001的订单 将被保存在 10001%4=1 即 t_order_1表；</li>
<li>其他同理。</li>
</ul>
<h5 id="常见的分库分表方案"><a href="#常见的分库分表方案" class="headerlink" title="常见的分库分表方案"></a>常见的分库分表方案</h5><ul>
<li><p>第一种是客户端型的，如 ShardingSphere(Sharding-JDBC)，分表路由等逻辑需要侵入到客户端的代码中。</p>
<img src="https://shardingsphere.apache.org/document/current/img/shardingsphere-jdbc-brief.png" alt="Sharding-JDBC" style="zoom:67%;" />
</li>
<li><p>第二种是基于代理型的，如 MyCat。这种中间件对客户端是透明的，客户端是不知道自己的请求被代理了的。</p>
<p><img src="http://www.mycat.org.cn/index_files/arc.png" alt="MyCat架构图"></p>
</li>
</ul>
<p>#####区别&amp;优缺点</p>
<ul>
<li>MyCat是一个三方中间件应用，需要独立部署并运行，ShardingJDBC是一个jar包，需要客户端集成；</li>
<li>MyCat代理数据库，ShardingJDBC是直连数据库，相比而言，后者在性能上更占优势；</li>
<li>二者在多表Join等特性及内部函数上存在不同的限制；</li>
<li>[个人理解] 目前工作中Sharding-JDBC用的多一点（了解到的像当当、喜马拉雅、微盟），因为MyCat需要专门的人员或团队去维护保证稳定性，而且就目前社区文档规范及活跃性来看，ShardingSphere也更好一点。</li>
</ul>
<h5 id="分片策略及分片算法"><a href="#分片策略及分片算法" class="headerlink" title="分片策略及分片算法"></a>分片策略及分片算法</h5><ul>
<li><p>分片策略与分片算法 二者区别与关系是什么？</p>
<p>算法是策略中抽象出来的逻辑与精髓，策略是算法结合业务场景的具体实现。（个人理解，不同见解请留言交流）</p>
</li>
<li><p>分片策略的两种维度</p>
<ul>
<li>数据源分片策略（DatabaseShardingStrategy）：通俗点说，就是作用于多个数据库实例之间。</li>
<li>表分片策略（TableShardingStrategy）：数据如何被分配到具体的表</li>
</ul>
</li>
<li><p>策略分类</p>
<ul>
<li>StandardShardingStrategy</li>
<li>ComplexShardingStrategy</li>
<li>InlineShardingStrategy</li>
<li>HintShardingStrategy</li>
<li>NoneShardingStrategy</li>
</ul>
<p>具体的分片策略及其区别推荐还是去官方阅读最新文档，<a href="https://shardingsphere.apache.org/document/current/en/features/sharding/concept/sharding/">这里</a>仅供参考。</p>
</li>
<li><p>算法分类</p>
<ul>
<li>PreciseShardingAlgorithm</li>
<li>RangeShardingAlgorithm</li>
<li>HintShardingAlgorithm</li>
<li>ComplexKeysShardingAlgorithm</li>
</ul>
</li>
</ul>
<p>Apache ShardingSphere 通过 SPI 方式允许开发者扩展算法，同时，它也内置了很多算法，详细可以阅读<a href="https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/configuration/built-in-algorithm/">官方文档</a> and <a href="https://shardingsphere.apache.org/document/current/cn/dev-manual/sharding/">Here</a>。</p>
<h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><p>Apache ShardingSphere 是一套开源的分布式数据库中间件解决方案组成的生态圈，其官网 <a href="http://shardingsphere.apache.org/index_zh.html">ShardingSphere</a>，官方的入门资料可以先参考，这里不做详细介绍。</p>
<h5 id="创建项目并添加依赖"><a href="#创建项目并添加依赖" class="headerlink" title="创建项目并添加依赖"></a>创建项目并添加依赖</h5><p>首先创建一个Maven管理的SpringBoot项目，并添加如下依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--mysql，根据自己数据库版本进行相关调整，不然会报错--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Mybatis-Plus--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- for spring boot --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;sharding-sphere.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- for spring namespace --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-namespace<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;sharding-sphere.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- lombok --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h5><p>然后创建数据库，为了实现<code>分库</code> 功能，这里创建两个数据库，分别是：<code>sharding_practice_0</code>和<code>sharding_practice_1</code>。</p>
<p>分别在数据库中创建表 <code>t_user_0</code>、<code>t_user_1、</code>t_order_0<code>、</code>t_order_1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;t_order_0&#96;  (</span><br><span class="line">  &#96;id&#96; bigint NOT NULL AUTO_INCREMENT COMMENT &#39;自增id&#39;,</span><br><span class="line">  &#96;order_no&#96; varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT &#39;订单号&#39;,</span><br><span class="line">  &#96;order_name&#96; varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT &#39;订单名称&#39;,</span><br><span class="line">  &#96;order_status&#96; int NOT NULL COMMENT &#39;订单状态&#39;,</span><br><span class="line">  &#96;user_id&#96; bigint NOT NULL COMMENT &#39;用户id&#39;,</span><br><span class="line">  &#96;create_time&#96; datetime(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT &#39;创建时间&#39;,</span><br><span class="line">  &#96;update_time&#96; datetime(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) ON UPDATE CURRENT_TIMESTAMP(0) COMMENT &#39;更新时间&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;) USING BTREE</span><br><span class="line">) ENGINE &#x3D; InnoDB AUTO_INCREMENT &#x3D; 1 CHARACTER SET &#x3D; utf8mb4 COLLATE &#x3D; utf8mb4_general_ci ROW_FORMAT &#x3D; DYNAMIC;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;t_user_0&#96;  (</span><br><span class="line">  &#96;id&#96; bigint NOT NULL AUTO_INCREMENT COMMENT &#39;自增id&#39;,</span><br><span class="line">  &#96;name&#96; varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT &#39;用户名&#39;,</span><br><span class="line">  &#96;mobile&#96; varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT &#39;订单名称&#39;,</span><br><span class="line">  &#96;address&#96; varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT &#39;&#39; COMMENT &#39;地址&#39;,</span><br><span class="line">  &#96;user_id&#96; bigint NOT NULL COMMENT &#39;用户id&#39;,</span><br><span class="line">  &#96;age&#96; int NOT NULL COMMENT &#39;年龄&#39;,</span><br><span class="line">  &#96;create_time&#96; datetime(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT &#39;创建时间&#39;,</span><br><span class="line">  &#96;update_time&#96; datetime(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) ON UPDATE CURRENT_TIMESTAMP(0) COMMENT &#39;更新时间&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;) USING BTREE</span><br><span class="line">) ENGINE &#x3D; InnoDB AUTO_INCREMENT &#x3D; 1 CHARACTER SET &#x3D; utf8mb4 COLLATE &#x3D; utf8mb4_general_ci ROW_FORMAT &#x3D; DYNAMIC;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>表结构都一样，就不重复贴了。</p>
<h5 id="创建实体类等"><a href="#创建实体类等" class="headerlink" title="创建实体类等"></a>创建实体类等</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;t_order&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderInfo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TableId(value = &quot;id&quot;,type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(value = &quot;order_no&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String orderNo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer orderStatus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;t_user&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TableId(value = &quot;id&quot;,type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mapper及Service直接省略，采用 mybatis-plus自动生成crud方法，不再贴出来。</p>
<h5 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h5><p>配置文件是重点，注释都在其中，简单易懂。</p>
<p>其中，t_order表使用分片策略：<code>order_no % 2</code>;</p>
<p>t_user表采用强制路由，在配置中指定路由算法类 <code>com.eqshen.shardingpractice.algorithm.UserHintAlgorithm</code>,在代码中指定路由的键值。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">sharding-practice</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8098</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据源 ds0,ds1</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.names</span>=<span class="string">ds0,ds1</span></span><br><span class="line"><span class="comment"># 第一个数据库</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds0.type</span>=<span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds0.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds0.jdbc-url</span>=<span class="string">jdbc:mysql://localhost:3306/sharding_practice_0?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8&amp;useSSL=false&amp;verifyServerCertificate=false&amp;autoReconnct=true&amp;autoReconnectForPools=true&amp;allowMultiQueries=true</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds0.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds0.password</span>=<span class="string">123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个数据库</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.type</span>=<span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.jdbc-url</span>=<span class="string">jdbc:mysql://localhost:3306/sharding_practice_1?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8&amp;useSSL=false&amp;verifyServerCertificate=false&amp;autoReconnct=true&amp;autoReconnectForPools=true&amp;allowMultiQueries=true</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.password</span>=<span class="string">123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 水平拆分的数据库（表） 配置分库 + 分表策略 行表达式分片策略</span></span><br><span class="line"><span class="comment">## 分库策略</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.default-database-strategy.inline.sharding-column</span>=<span class="string">order_no</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.default-database-strategy.inline.algorithm-expression</span>=<span class="string">ds$-&gt;&#123;order_no % 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## t_order分表策略</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.actual-data-nodes</span>=<span class="string">ds$-&gt;&#123;0..1&#125;.t_order_$-&gt;&#123;0..1&#125;</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.key-generator.column</span>=<span class="string">order_no</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.key-generator.type</span>=<span class="string">SNOWFLAKE</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.table-strategy.inline.sharding-column</span>=<span class="string">order_no</span></span><br><span class="line"><span class="comment">###分片算法表达式</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.table-strategy.inline.algorithm-expression</span>=<span class="string">t_order_$-&gt;&#123;order_no % 2&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## t_user 分表策略</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_user.actual-data-nodes</span>=<span class="string">ds$-&gt;&#123;0..1&#125;.t_user_$-&gt;&#123;0..1&#125;</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_user.key-generator.column</span>=<span class="string">user_id</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_user.key-generator.type</span>=<span class="string">SNOWFLAKE</span></span><br><span class="line"><span class="comment">### 强制路由</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_user.database-strategy.hint.algorithm-class-name</span>=<span class="string">com.eqshen.shardingpractice.algorithm.UserHintAlgorithm</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_user.table-strategy.hint.algorithm-class-name</span>=<span class="string">com.eqshen.shardingpractice.algorithm.UserHintAlgorithm</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印执行的数据库以及语句</span></span><br><span class="line"><span class="meta">spring.shardingsphere.props.sql.show</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.main.allow-bean-definition-overriding</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># mybatis-plus</span></span><br><span class="line"><span class="meta">mybatis-plus.mapper-locations</span>=<span class="string">classpath:/mapper/*.xml</span></span><br><span class="line"><span class="meta">mybatis-plus.configuration.jdbc-type-for-null</span>=<span class="string">&#x27;null&#x27;</span></span><br></pre></td></tr></table></figure>

<p>完成以上内容就可以开始测试了</p>
<h5 id="强制路由"><a href="#强制路由" class="headerlink" title="强制路由"></a>强制路由</h5><p>何为强制路由？ 且看官方原话。</p>
<ul>
<li>使用动机</li>
</ul>
<blockquote>
<p>通过解析 SQL 语句提取分片键列与值并进行分片是 Apache ShardingSphere 对 SQL 零侵入的实现方式。若 SQL 语句中没有分片条件，则无法进行分片，需要全路由。</p>
<p>在一些应用场景中，分片条件并不存在于 SQL，而存在于外部业务逻辑。因此需要提供一种通过外部指定分片结果的方式，在 Apache ShardingSphere 中叫做 Hint。</p>
</blockquote>
<ul>
<li>实现机制</li>
</ul>
<blockquote>
<p>Apache ShardingSphere 使用 <code>ThreadLocal</code> 管理分片键值。可以通过编程的方式向 <code>HintManager</code> 中添加分片条件，该分片条件仅在当前线程内生效。</p>
<p>除了通过编程的方式使用强制分片路由，Apache ShardingSphere 还计划通过 SQL 中的特殊注释的方式引用 Hint，使开发者可以采用更加透明的方式使用该功能。</p>
<p>指定了强制分片路由的 SQL 将会无视原有的分片逻辑，直接路由至指定的真实数据节点。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHintAlgorithm</span> <span class="keyword">implements</span> <span class="title">HintShardingAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doSharding</span><span class="params">(Collection collection, HintShardingValue hintShardingValue)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;强制路由开始，表总数：&#123;&#125;，路由字段：&#123;&#125;&quot;</span>,collection,hintShardingValue.getColumnName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Collection shardingValues = hintShardingValue.getValues();</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Object o : collection) &#123;</span><br><span class="line">            String targetName = (String) o;</span><br><span class="line">            String suffix = targetName.substring(targetName.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (Object value : shardingValues) &#123;</span><br><span class="line">                Integer v = <span class="keyword">new</span> Integer(value+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(v % <span class="number">2</span> == Integer.parseInt(suffix))&#123;</span><br><span class="line">                    log.info(<span class="string">&quot;值：&#123;&#125; 被路由到表：&#123;&#125;&quot;</span>,v,targetName);</span><br><span class="line">                    result.add(targetName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;强制路由结束：&#123;&#125;&quot;</span>,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>创建测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShardingPracticeApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试分片</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            OrderInfo orderInfo = <span class="keyword">new</span> OrderInfo();</span><br><span class="line">            orderInfo.setOrderStatus(<span class="number">1</span>);</span><br><span class="line">            orderInfo.setUserId(<span class="number">10001L</span> + i);</span><br><span class="line">            orderInfo.setOrderName(<span class="string">&quot;黄焖鸡米饭&quot;</span> + LocalDateTime.now().toString());</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> save = <span class="keyword">this</span>.orderService.save(orderInfo);</span><br><span class="line">            log.info(<span class="string">&quot;============done:&#123;&#125;&quot;</span>,save);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试强制路由</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testHint</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> ; i++) &#123;</span><br><span class="line">            HintManager hintManager = HintManager.getInstance();</span><br><span class="line">            hintManager.addDatabaseShardingValue(<span class="string">&quot;t_user&quot;</span>,i%<span class="number">2</span>);</span><br><span class="line">            hintManager.addTableShardingValue(<span class="string">&quot;t_user&quot;</span>,i%<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            UserInfo userInfo = <span class="keyword">new</span> UserInfo();</span><br><span class="line">            userInfo.setAddress(<span class="string">&quot;上海市黄浦区延安东路618号&quot;</span>);</span><br><span class="line">            userInfo.setAge(<span class="number">18</span>);</span><br><span class="line">            userInfo.setName(<span class="string">&quot;张飞&quot;</span>+ i);</span><br><span class="line">            userInfo.setMobile(<span class="string">&quot;1762134523&quot;</span>+i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> save = <span class="keyword">this</span>.userService.save(userInfo);</span><br><span class="line">            log.info(<span class="string">&quot;============done:&#123;&#125;&quot;</span>,save);</span><br><span class="line">            hintManager.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>完整的代码参见github  <a href="https://github.com/eqshen/sharding-practice">ShardingJDBC菜鸟入门练习</a></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><p><a href="https://my.oschina.net/u/4318872/blog/4281049">MyCat和ShardingJDBC对比</a></p>
</li>
<li><p><a href="http://www.mycat.org.cn/">MyCat官网</a></p>
</li>
<li><p><a href="https://shardingsphere.apache.org/">ShardingSphere官网</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>实践</category>
        <category>分库分表</category>
      </categories>
      <tags>
        <tag>实践</tag>
        <tag>分库分表</tag>
        <tag>ShardingSphere</tag>
      </tags>
  </entry>
  <entry>
    <title>从审计日志(操作日志)说起</title>
    <url>/2021/09/21/%E4%BB%8E%E5%AE%A1%E8%AE%A1%E6%97%A5%E5%BF%97-%E6%93%8D%E4%BD%9C-%E8%AF%B4%E8%B5%B7/</url>
    <content><![CDATA[<h3 id="从审计日志-操作日志-说起"><a href="#从审计日志-操作日志-说起" class="headerlink" title="从审计日志(操作日志)说起"></a>从审计日志(操作日志)说起</h3><p>时隔一年，偷懒了一年，再次开始写日志，补补技术债</p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在公司日常的开发中，经常会遇到记录操作（审计）日志的情况，格式像这样：<code>法外狂人张三 修改了 xxx配置，从 123 修改为 456，影响 1 行</code>。如果一个项目中crud的接口比较少，那我们完全可以在 接口中硬编码，这中方式也是最直接最快的方式，但是对于一个追求完美的“技术癖”来说，还是存在以下担忧的地方</p>
<ul>
<li>接口可能不是同一个人开发，日志的格式如何统一？模板方法？</li>
<li>后续修改，每个地方都要修改，工作量就比较大，不好维护</li>
<li>通用逻辑植入业务代码，很不爽</li>
<li>每个接口入参和出参格式不一样，如何从中提取参数信息？</li>
</ul>
<h4 id="具体需求举例"><a href="#具体需求举例" class="headerlink" title="具体需求举例"></a>具体需求举例</h4><p>各个业务需要统一将操作日志记录并统一上报，上报的报文要包含以下内容：</p>
<ul>
<li>操作人  : 操作人的userId</li>
<li>操作时间：2021年09月21日14:31:34</li>
<li>操作类型：C - 增加，R - 读，U - 更新，D - 删除</li>
<li>操作对象：如 orderNo , userId</li>
<li>影响行数：22</li>
</ul>
<p>其中影响行数，在读取的情况下指读取的行数，写的情况下指影响的行数，这些都是要根据具体的业务逻辑来确定的，无法抽象共用</p>
<p>| 以上就是一个具体的需求内容简化，接下来就是方案设计了。</p>
<h4 id="常见的解决方案"><a href="#常见的解决方案" class="headerlink" title="常见的解决方案"></a>常见的解决方案</h4><ol>
<li><p>从数据层面入手，订阅数据库Binlog<br> 简单来说，就是通过Canal订阅MySQL的binlog, 这样每次就能知道哪张表、哪行被修改了。</p>
<ul>
<li>好处：直接和业务逻辑解耦</li>
<li>缺点：复杂的业务逻辑无法表现出来，如果一个接口中修改了很多接口，甚至还有RPC调用，这种情况下就不太实用这种方案了。</li>
</ul>
</li>
<li><p>定义类似LogUtil一样的工具类，抽象入参，在工具类中实现模板化，在需要记录日志的地方调用工具类</p>
<p> 这种方式也是比较容易想到，而且是比较简单的实现。</p>
</li>
<li><p>自定义注解 + Aop + SpEL实现解耦</p>
<p> 这种方法就是我们要实现的方式了，要做一个有追求的<code>新时代农民工</code>。</p>
</li>
</ol>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><ol>
<li>首先定义注解<br>用于在controller方法上进行标记，并提供切面标记</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">public @interface AuditLog &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 操作类型</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    OperateType operateType();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 操作对象表达式</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    String opTargetEL();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 影响行数表达式</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    String effectRowsEL();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义使用到的实体类</li>
</ol>
<p>用于存储 AuditLog 在aop过程中所需要的中间过程数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 存储切面过程中一些元数据</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Data</span><br><span class="line">public class AuditLogAopMetaDTO &#123;</span><br><span class="line">    private HttpServletRequest httpServletRequest;</span><br><span class="line"></span><br><span class="line">    private AuditLog auditLog;</span><br><span class="line"></span><br><span class="line">    private String httpMethodType;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Get请求参数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Map&lt;String,Object&gt; reqParam;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Post请求参数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Object postParam;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用于存储最终的操作日志结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 操作日志对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Data</span><br><span class="line">public class AuditLogDTO &#123;</span><br><span class="line"></span><br><span class="line">    private LocalDateTime opTime;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @see com.eqshen.auditlogstarter.enums.OperateType</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String operateType;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 操作人账号或id</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String opAccount;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 操作对象，如 订单号，用户id等</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String opTarget;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 操作结果，影响行数等</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String opResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>定义切面处理类</li>
</ol>
<p>这里是主要的逻辑, 代码不复杂。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class AuditLogInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;@annotation(com.eqshen.auditlogstarter.annotation.AuditLog)&quot;)</span><br><span class="line">    public void pointcut()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;pointcut()&quot;)</span><br><span class="line">    public Object around(ProceedingJoinPoint point) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">        Object result &#x3D; null;</span><br><span class="line">        final AuditLogDTO auditLogDTO;</span><br><span class="line">        final AuditLogAopMetaDTO auditLogAopMetaDTO &#x3D; this.beforeProcess(point);</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            result &#x3D; point.proceed();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            auditLogDTO &#x3D; this.afterProcess(auditLogAopMetaDTO, result);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;异步推送kafka</span><br><span class="line">            this.asyncSendToKafka(auditLogDTO);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private AuditLogAopMetaDTO beforeProcess(ProceedingJoinPoint point)&#123;</span><br><span class="line">        AuditLogAopMetaDTO auditLogAopMetaDTO &#x3D; new AuditLogAopMetaDTO();</span><br><span class="line">        try&#123;</span><br><span class="line">            RequestAttributes ra &#x3D; RequestContextHolder.getRequestAttributes();</span><br><span class="line">            ServletRequestAttributes sra &#x3D; (ServletRequestAttributes) ra;</span><br><span class="line">            if (sra &#x3D;&#x3D; null) return null;</span><br><span class="line"></span><br><span class="line">            final HttpServletRequest request &#x3D; sra.getRequest();</span><br><span class="line"></span><br><span class="line">            String methodType &#x3D; request.getMethod();;</span><br><span class="line">            Method method &#x3D; AopUtil.getMethod(point);</span><br><span class="line">            AuditLog auditLog &#x3D; method.getAnnotation(AuditLog.class);</span><br><span class="line"></span><br><span class="line">            auditLogAopMetaDTO.setAuditLog(auditLog);</span><br><span class="line">            auditLogAopMetaDTO.setHttpMethodType(methodType);</span><br><span class="line">            auditLogAopMetaDTO.setHttpServletRequest(request);</span><br><span class="line">            auditLogAopMetaDTO.setReqParam(AopUtil.getParamsNameAndValue(point));</span><br><span class="line">            auditLogAopMetaDTO.setPostParam(AopUtil.getPostParam(point));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            log.error(&quot;预处理失败&quot;,e);</span><br><span class="line">        &#125;</span><br><span class="line">        return auditLogAopMetaDTO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private AuditLogDTO afterProcess(AuditLogAopMetaDTO aopMeta, Object result)&#123;</span><br><span class="line">        if(aopMeta &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        final AuditLog auditLog &#x3D; aopMeta.getAuditLog();</span><br><span class="line"></span><br><span class="line">        Object opTarget &#x3D; SpELUtil.explainEl(aopMeta.getPostParam(),auditLog.opTargetEL());</span><br><span class="line"></span><br><span class="line">        if(opTarget &#x3D;&#x3D; null)&#123;</span><br><span class="line">            opTarget &#x3D; SpELUtil.explainEl(aopMeta.getReqParam(),auditLog.opTargetEL());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String effectRows &#x3D; String.valueOf(SpELUtil.explainEl(result,auditLog.effectRowsEL()));</span><br><span class="line"></span><br><span class="line">        AuditLogDTO auditLogDTO &#x3D; new AuditLogDTO();</span><br><span class="line">        auditLogDTO.setOpTime(LocalDateTime.now());</span><br><span class="line">        auditLogDTO.setOperateType(auditLogDTO.getOperateType());</span><br><span class="line">        auditLogDTO.setOpAccount(null);&#x2F;&#x2F;一般从Context中获取当前登录的用户信息</span><br><span class="line">        auditLogDTO.setOpResult(effectRows);</span><br><span class="line">        auditLogDTO.setOpTarget(String.valueOf(opTarget&#x3D;&#x3D;null?&quot;&quot;:opTarget));</span><br><span class="line"></span><br><span class="line">        return auditLogDTO;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void asyncSendToKafka(AuditLogDTO auditLogDTO)&#123;</span><br><span class="line">        if(auditLogDTO &#x3D;&#x3D; null) return;</span><br><span class="line">        &#x2F;&#x2F;推荐使用线程数池操作,此处仅输出日志</span><br><span class="line">        log.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 操作日志：&#123;&#125;&quot;, JSONObject.toJSONString(auditLogDTO));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的一个 SpELUtil工具类是用来解析spel表达式的，也很简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class SpELUtil &#123;</span><br><span class="line">    &#x2F;&#x2F;thread-safe</span><br><span class="line">    private static final SpelExpressionParser parser &#x3D; new SpelExpressionParser();</span><br><span class="line"></span><br><span class="line">    private static final TemplateParserContext parserContext &#x3D; new TemplateParserContext(&quot;#&#123;&quot;, &quot;&#125;&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static Object explainEl(Object obj, String spELExpression)&#123;</span><br><span class="line">        if (StringUtils.isEmpty(spELExpression) || obj &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; spring的表达式上下文对象</span><br><span class="line">            StandardEvaluationContext context &#x3D; new StandardEvaluationContext();</span><br><span class="line">            context.addPropertyAccessor(new MapAccessor());&#x2F;&#x2F;增加对map的访问支持</span><br><span class="line">            context.setRootObject(obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Expression expression &#x3D; parser.parseExpression(spELExpression, parserContext);</span><br><span class="line">            return expression.getValue(context);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;SpEL解析失败, 表达式: &#123;&#125;, 输入: &#123;&#125;&quot;, spELExpression, JSONObject.toJSONString(obj), e);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>测试<br>定义TestController，简单演示如何使用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class TestController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;listUsers&quot;)</span><br><span class="line">    @AuditLog(opTargetEL &#x3D; &quot;&quot;,operateType &#x3D; OperateType.READ,effectRowsEL &#x3D; &quot;#&#123;data.size()&#125;&quot;)</span><br><span class="line">    public JSONObject queryUserList()&#123;</span><br><span class="line">        JSONObject resp &#x3D; new JSONObject();</span><br><span class="line">        resp.put(&quot;code&quot;,200);</span><br><span class="line">        resp.put(&quot;msg&quot;,&quot;success&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;UserInfo&gt; userList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        userList.add(new UserInfo(&quot;u-007&quot;,&quot;张三&quot;,2,&quot;17621345678&quot;));</span><br><span class="line">        userList.add(new UserInfo(&quot;u-001&quot;,&quot;李四&quot;,3,&quot;17621345679&quot;));</span><br><span class="line"></span><br><span class="line">        resp.put(&quot;data&quot;,userList);</span><br><span class="line">        return resp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;getUserInfo&quot;)</span><br><span class="line">    @AuditLog(operateType &#x3D; OperateType.READ,</span><br><span class="line">            opTargetEL &#x3D; &quot;查询用户信息：#&#123;userId&#125;&quot;,</span><br><span class="line">            effectRowsEL &#x3D; &quot;#&#123;data &#x3D;&#x3D; null?0:1&#125;&quot;)</span><br><span class="line">    public JSONObject getUser(String userId)&#123;</span><br><span class="line">        JSONObject resp &#x3D; new JSONObject();</span><br><span class="line">        resp.put(&quot;code&quot;,200);</span><br><span class="line">        resp.put(&quot;msg&quot;,&quot;success&quot;);</span><br><span class="line">        resp.put(&quot;data&quot;,new UserInfo(&quot;u-007&quot;,&quot;张三&quot;,2,&quot;17621345678&quot;));</span><br><span class="line"></span><br><span class="line">        return resp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;operateUser&quot;)</span><br><span class="line">    @AuditLog(operateType &#x3D; OperateType.UPDATE,</span><br><span class="line">            opTargetEL &#x3D; &quot;用户id: #&#123;userId&#125;&quot;, &#x2F;&#x2F;必须跟 userInfo对象中的属性名称一致</span><br><span class="line">            effectRowsEL &#x3D; &quot;#&#123;code &#x3D;&#x3D; 200?1:0&#125;&quot;)</span><br><span class="line">    public JSONObject operateUser(@RequestBody UserInfo userInfo)&#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;用于测试异常情况</span><br><span class="line">        if(Objects.equals(userInfo.getUserId(), &quot;1234&quot;))&#123;</span><br><span class="line">            throw new RuntimeException(&quot;用户不存在&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        JSONObject resp &#x3D; new JSONObject();</span><br><span class="line">        resp.put(&quot;code&quot;,200);</span><br><span class="line">        resp.put(&quot;msg&quot;,&quot;success&quot;);</span><br><span class="line">        return resp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试1<br>请求及返回：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET http:&#x2F;&#x2F;localhost:8080&#x2F;listUsers</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 200 </span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Sat, 25 Sep 2021 09:10:57 GMT</span><br><span class="line">Keep-Alive: timeout&#x3D;60</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;msg&quot;: &quot;success&quot;,</span><br><span class="line">  &quot;code&quot;: 200,</span><br><span class="line">  &quot;data&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;userId&quot;: &quot;u-007&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;张三&quot;,</span><br><span class="line">      &quot;level&quot;: 2,</span><br><span class="line">      &quot;mobile&quot;: &quot;17621345678&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;userId&quot;: &quot;u-001&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;李四&quot;,</span><br><span class="line">      &quot;level&quot;: 3,</span><br><span class="line">      &quot;mobile&quot;: &quot;17621345679&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>日志输出：<br><code>======&gt; 操作日志：&#123;&quot;opResult&quot;:&quot;2&quot;,&quot;opTarget&quot;:&quot;&quot;,&quot;opTime&quot;:&quot;2021-09-25T17:07:38.093127000&quot;&#125; </code></p>
<ul>
<li>测试2<br>请求及返回： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET http:&#x2F;&#x2F;localhost:8080&#x2F;getUserInfo?userId&#x3D;1234</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 200 </span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Sat, 25 Sep 2021 09:09:11 GMT</span><br><span class="line">Keep-Alive: timeout&#x3D;60</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;msg&quot;: &quot;success&quot;,</span><br><span class="line">  &quot;code&quot;: 200,</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;userId&quot;: &quot;u-007&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;张三&quot;,</span><br><span class="line">    &quot;level&quot;: 2,</span><br><span class="line">    &quot;mobile&quot;: &quot;17621345678&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>日志输出：<br><code>======&gt; 操作日志：&#123;&quot;opResult&quot;:&quot;1&quot;,&quot;opTarget&quot;:&quot;查询用户信息：1234&quot;,&quot;opTime&quot;:&quot;2021-09-25T17:11:40.489187000&quot;&#125; </code></p>
<ul>
<li>测试3<br>请求及返回：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST http:&#x2F;&#x2F;localhost:8080&#x2F;operateUser</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 200 </span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Sat, 25 Sep 2021 09:12:49 GMT</span><br><span class="line">Keep-Alive: timeout&#x3D;60</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;msg&quot;: &quot;success&quot;,</span><br><span class="line">  &quot;code&quot;: 200</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>日志输出：<br><code>======&gt; 操作日志：&#123;&quot;opResult&quot;:&quot;1&quot;,&quot;opTarget&quot;:&quot;用户id: 12345&quot;,&quot;opTime&quot;:&quot;2021-09-25T17:13:47.193806000&quot;&#125; </code></p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ol>
<li>关于SpEL的语法可以去看Spring官方文档<ul>
<li><a href="http://itmyhome.com/spring/expressions.html">http://itmyhome.com/spring/expressions.html</a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html">https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html</a></li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>完整仓库地址</p>
<ul>
<li><a href="https://github.com/eqshen/audit-log-starter">https://github.com/eqshen/audit-log-starter</a></li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>插件集成-类加载简单实践及踩坑</title>
    <url>/2022/01/09/%E6%8F%92%E4%BB%B6%E9%9B%86%E6%88%90-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%AE%80%E5%8D%95%E5%AE%9E%E8%B7%B5%E5%8F%8A%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<h3 id="插件集成-类加载简单实践及踩坑"><a href="#插件集成-类加载简单实践及踩坑" class="headerlink" title="插件集成-类加载简单实践及踩坑"></a>插件集成-类加载简单实践及踩坑</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h4><p>在项目中，有这样一个需求场景，系统web端要支持插件功能，插件功能其中一点就是要支持 jar包上传（jar包中包含插件逻辑），然后把插件应用在某个流程中。如：要把IP地址 192.168.12.13 转为 192.168.12。</p>
<p>支持插件的一个好处就是，一些前置转换就比较灵活，不需要每次都改代码重新部署。</p>
<h4 id="V1-Begin-to-explore"><a href="#V1-Begin-to-explore" class="headerlink" title="V1 Begin to explore"></a><strong>V1 Begin to explore</strong></h4><p>项目中定义一个模板接口 IPluginJarTemplate，所有jar插件需要实现该模板接口 IPluginJarTemplate。然后利用JAVA SPI加载 IPluginJarTemplate的所有实现类的实例并缓存备用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PluginJarClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JarFile jarFile;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PluginJarClassLoader</span><span class="params">(ClassLoader parent,JarFile jar)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.jarFile = jar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        String filename = className.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        JarEntry jarEntry = jarFile.getJarEntry(filename);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(jarEntry == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(filename);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>(InputStream inputStream = jarFile.getInputStream(jarEntry))&#123;</span><br><span class="line">            ByteArrayOutputStream byteStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> nextValue;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != (nextValue = inputStream.read())) &#123;</span><br><span class="line">                byteStream.write(nextValue);</span><br><span class="line">            &#125;</span><br><span class="line">            classBytes = byteStream.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;插件加载类出错： class : &#123;&#125;,error: &#123;&#125;&quot;</span>,filename,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(filename);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> defineClass(className, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>类加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PluginJarClassLoader pluginJarClassLoader = <span class="keyword">new</span> PluginJarClassLoader(ClassLoader.getSystemClassLoader(), <span class="keyword">new</span> JarFile(file));</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用JAVA SPI加载IPluginJarTemplate所有实现类实例</span></span><br><span class="line">ServiceLoader&lt;IPluginJarTemplate&gt; allImplementations = ServiceLoader.load(IPluginJarTemplate.class, pluginJarClassLoader);</span><br><span class="line">Iterator&lt;IPluginJarTemplate&gt; iterator = allImplementations.iterator();</span><br><span class="line"><span class="keyword">if</span> (iterator.hasNext())&#123;</span><br><span class="line">    IPluginJarTemplate funcImplementation = iterator.next();</span><br><span class="line">    String cacheKey = PluginJarFileCache.genCacheKey(pluginDto);</span><br><span class="line">    PluginJarFileCache.put(cacheKey,funcImplementation);</span><br><span class="line">    log.info(<span class="string">&quot;加载Jar类：&#123;&#125;&quot;</span>,funcImplementation.getClass().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>但上述加载流程存在问题，无法加载到类</p>
<p>Debug跟进SPI源码，发现关键点在于 loader.getResources(fullName) ，见下方代码，fullName这个变量的值形如：META-INF/services/xxxxx , 也就是说，会通过自定义类加载器去加载 SPI所需的配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LazyIterator</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.service = service;</span><br><span class="line">            <span class="keyword">this</span>.loader = loader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String fullName = PREFIX + service.getName();</span><br><span class="line">                    <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                        configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        configs = loader.getResources(fullName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                    fail(service, <span class="string">&quot;Error locating configuration files&quot;</span>, x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pending = parse(service, configs.nextElement());</span><br><span class="line">            &#125;</span><br><span class="line">            nextName = pending.next();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p>而我们自定义类加载的继承关系是 PluginJarClassLoader extends ClassLoader , 而getResources方法 ClassLoader 的默认实现是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;URL&gt; <span class="title">getResources</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Enumeration&lt;URL&gt;[] tmp = (Enumeration&lt;URL&gt;[]) <span class="keyword">new</span> Enumeration&lt;?&gt;[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tmp[<span class="number">0</span>] = parent.getResources(name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp[<span class="number">0</span>] = getBootstrapResources(name);</span><br><span class="line">    &#125;</span><br><span class="line">    tmp[<span class="number">1</span>] = findResources(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CompoundEnumeration&lt;&gt;(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通过上述代码，不难发现关键点来到了 tmp[1] = findResources(name) 这个地方，而 findResources的默认实现是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Enumeration&lt;URL&gt; <span class="title">findResources</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> java.util.Collections.emptyEnumeration();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>所以无法加载插件中的类，就自然不难理解了。</p>
<h4 id="V2-How-to-reslove"><a href="#V2-How-to-reslove" class="headerlink" title="V2 How to reslove"></a><strong>V2 How to reslove</strong></h4><p>到这，就有两种方法了</p>
<ul>
<li>第一，自定义类加载器中重写 findResources</li>
<li>第二，找一个 已经重写了findResources方法的类加载器，通过类继承关系，发现URLClassLoader符合条件</li>
</ul>
<p>两种方法我们都试一下</p>
<h5 id="重写findResources"><a href="#重写findResources" class="headerlink" title="重写findResources"></a><strong>重写findResources</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Enumeration&lt;URL&gt; <span class="title">findResources</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        JarEntry jarEntry = jarFile.getJarEntry(name);</span><br><span class="line">        <span class="keyword">if</span>(jarEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到资源&quot;</span> + jarEntry.getName());</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;/tmp/jarEntry_temp&quot;</span>);</span><br><span class="line">            FileUtil.writeFromStream(jarFile.getInputStream(jarEntry), file);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Collections.enumeration(Collections.singletonList(file.toURI().toURL()));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> java.util.Collections.emptyEnumeration();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>然后测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        JarFile jarFile = <span class="keyword">new</span> JarFile(<span class="string">&quot;/Users/eqshen/workspace/plugin-review/plugin-client/build/libs/plugin-client-1.0-SNAPSHOT.jar&quot;</span>);</span><br><span class="line">        PluginJarClassLoader classLoader = <span class="keyword">new</span> PluginJarClassLoader(<span class="keyword">this</span>.getClass().getClassLoader(), jarFile);</span><br><span class="line"></span><br><span class="line">        ServiceLoader&lt;IPluginJarTemplate&gt; allImplementations = ServiceLoader.load(IPluginJarTemplate.class, classLoader);</span><br><span class="line">        Iterator&lt;IPluginJarTemplate&gt; iterator = allImplementations.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            IPluginJarTemplate funcImplementation = iterator.next();</span><br><span class="line">            log.info(<span class="string">&quot;加载Jar类：&#123;&#125;&quot;</span>,funcImplementation.getClass().getName());</span><br><span class="line">            log.info(<span class="string">&quot;======= result: &#123;&#125;&quot;</span>,funcImplementation.execute(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>测试发现类成功加载并执行</p>
<h5 id="使用URLClassLoader"><a href="#使用URLClassLoader" class="headerlink" title="使用URLClassLoader"></a><strong>使用URLClassLoader</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/eqshen/workspace/plugin-review/plugin-client/build/libs/plugin-client-1.0-SNAPSHOT.jar&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ClassLoader ucl = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[] &#123;file.toURI().toURL()&#125;, <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">        ServiceLoader&lt;IPluginJarTemplate&gt; allImplementations = ServiceLoader.load(IPluginJarTemplate.class, ucl);</span><br><span class="line">        Iterator&lt;IPluginJarTemplate&gt; iterator = allImplementations.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            IPluginJarTemplate funcImplementation = iterator.next();</span><br><span class="line">            log.info(<span class="string">&quot;=======result: &#123;&#125;&quot;</span>,funcImplementation.execute(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>));</span><br><span class="line">            log.info(<span class="string">&quot;加载Jar类：&#123;&#125;&quot;</span>,funcImplementation.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>通过这种方式，也可以成功加载 IPluginJarTemplate的所有实现类。</p>
<p>显然，通过第二种方式更简洁、符合实际应用</p>
<h4 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a><strong>踩坑</strong></h4><p>其实上面 通过 URLClassLoader加载的方式还是有个坑的， URLClassLoader构造函数传入的父类是 ClassLoader.getSystemClassLoader(), 这个代码在本地IDEA中启动是没问题的，但是如果发到测试环境或者本地通过 java -jar的方式启动，就会报错 ServiceConfigurationError not subtype, 通过google查找资源，大概了解到原因如下：</p>
<ul>
<li>plugin-management-spi-1.0-SNAPSHOT.jar 这个jar包中包含了 IPluginJarTemplate.class这个类，由URLClassloader加载器加载</li>
<li>而我们插件使用的项目中也存在 IPluginJarTemplate.class这个类，由 未知类加载器（暂时称为X）加载， X肯定不等于 ClassLoader.getSystemClassLoader()</li>
<li>在使用 ServiceLoader.load(IPluginJarTemplate.class, ucl) 获得类的实例的时候，会把 URLClassloader 加载的 IPluginJarTemplate.class子类 实例执行 X类加载器加载的 IPluginJarTemplate.class （多态的表现）</li>
<li>虽然 二者逻辑上是 父子关系，但分别由两个类加载器加载，则报错</li>
</ul>
<h5 id="证实一下猜想"><a href="#证实一下猜想" class="headerlink" title="证实一下猜想"></a><strong>证实一下猜想</strong></h5><p>​      </p>
<p>​     </p>
<p>​      </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader parent = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">log.info(<span class="string">&quot;parent classloader: &#123;&#125;,system:&#123;&#125;&quot;</span>,parent,ClassLoader.getSystemClassLoader());</span><br><span class="line">ClassLoader ucl = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[] &#123;file.toURI().toURL()&#125;, parent);</span><br></pre></td></tr></table></figure>



<p>只需要证明 this.getClass().getClassLoader() 和 ClassLoader.getSystemClassLoader() 不是同一个就能说得通了</p>
<p>本地IDEA跑起来，上面二者确实相同，都是AppClassLoader，但以java -jar的方式运行，输出日志如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">parent classloader:org.springframework.boot.loader.LaunchedURLClassLoader@<span class="number">7</span>c51f34b，system:sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>实践</category>
        <category>类加载</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>类加载</tag>
      </tags>
  </entry>
</search>
